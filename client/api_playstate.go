/*
 * Jellyfin API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * API version: v1
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package client

import (
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
	"github.com/antihax/optional"
)

// Linger please
var (
	_ _context.Context
)

// PlaystateApiService PlaystateApi service
type PlaystateApiService service

// MarkPlayedItemOpts Optional parameters for the method 'MarkPlayedItem'
type MarkPlayedItemOpts struct {
    DatePlayed optional.Time
}

/*
MarkPlayedItem Marks an item as played for user.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param userId User id.
 * @param itemId Item id.
 * @param optional nil or *MarkPlayedItemOpts - Optional Parameters:
 * @param "DatePlayed" (optional.Time) -  Optional. The date the item was played.
@return UserItemDataDto
*/
func (a *PlaystateApiService) MarkPlayedItem(ctx _context.Context, userId string, itemId string, localVarOptionals *MarkPlayedItemOpts) (UserItemDataDto, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  UserItemDataDto
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Users/{userId}/PlayedItems/{itemId}"
	localVarPath = strings.Replace(localVarPath, "{"+"userId"+"}", _neturl.QueryEscape(parameterToString(userId, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"itemId"+"}", _neturl.QueryEscape(parameterToString(itemId, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.DatePlayed.IsSet() {
		localVarQueryParams.Add("datePlayed", parameterToString(localVarOptionals.DatePlayed.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["X-Emby-Authorization"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
MarkUnplayedItem Marks an item as unplayed for user.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param userId User id.
 * @param itemId Item id.
@return UserItemDataDto
*/
func (a *PlaystateApiService) MarkUnplayedItem(ctx _context.Context, userId string, itemId string) (UserItemDataDto, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  UserItemDataDto
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Users/{userId}/PlayedItems/{itemId}"
	localVarPath = strings.Replace(localVarPath, "{"+"userId"+"}", _neturl.QueryEscape(parameterToString(userId, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"itemId"+"}", _neturl.QueryEscape(parameterToString(itemId, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["X-Emby-Authorization"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// OnPlaybackProgressOpts Optional parameters for the method 'OnPlaybackProgress'
type OnPlaybackProgressOpts struct {
    MediaSourceId optional.String
    PositionTicks optional.Int64
    AudioStreamIndex optional.Int32
    SubtitleStreamIndex optional.Int32
    VolumeLevel optional.Int32
    PlayMethod optional.Interface
    LiveStreamId optional.String
    PlaySessionId optional.String
    RepeatMode optional.Interface
    IsPaused optional.Bool
    IsMuted optional.Bool
}

/*
OnPlaybackProgress Reports a user's playback progress.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param userId User id.
 * @param itemId Item id.
 * @param optional nil or *OnPlaybackProgressOpts - Optional Parameters:
 * @param "MediaSourceId" (optional.String) -  The id of the MediaSource.
 * @param "PositionTicks" (optional.Int64) -  Optional. The current position, in ticks. 1 tick = 10000 ms.
 * @param "AudioStreamIndex" (optional.Int32) -  The audio stream index.
 * @param "SubtitleStreamIndex" (optional.Int32) -  The subtitle stream index.
 * @param "VolumeLevel" (optional.Int32) -  Scale of 0-100.
 * @param "PlayMethod" (optional.Interface of PlayMethod) -  The play method.
 * @param "LiveStreamId" (optional.String) -  The live stream id.
 * @param "PlaySessionId" (optional.String) -  The play session id.
 * @param "RepeatMode" (optional.Interface of RepeatMode) -  The repeat mode.
 * @param "IsPaused" (optional.Bool) -  Indicates if the player is paused.
 * @param "IsMuted" (optional.Bool) -  Indicates if the player is muted.
*/
func (a *PlaystateApiService) OnPlaybackProgress(ctx _context.Context, userId string, itemId string, localVarOptionals *OnPlaybackProgressOpts) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Users/{userId}/PlayingItems/{itemId}/Progress"
	localVarPath = strings.Replace(localVarPath, "{"+"userId"+"}", _neturl.QueryEscape(parameterToString(userId, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"itemId"+"}", _neturl.QueryEscape(parameterToString(itemId, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.MediaSourceId.IsSet() {
		localVarQueryParams.Add("mediaSourceId", parameterToString(localVarOptionals.MediaSourceId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PositionTicks.IsSet() {
		localVarQueryParams.Add("positionTicks", parameterToString(localVarOptionals.PositionTicks.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AudioStreamIndex.IsSet() {
		localVarQueryParams.Add("audioStreamIndex", parameterToString(localVarOptionals.AudioStreamIndex.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SubtitleStreamIndex.IsSet() {
		localVarQueryParams.Add("subtitleStreamIndex", parameterToString(localVarOptionals.SubtitleStreamIndex.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.VolumeLevel.IsSet() {
		localVarQueryParams.Add("volumeLevel", parameterToString(localVarOptionals.VolumeLevel.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PlayMethod.IsSet() {
		localVarQueryParams.Add("playMethod", parameterToString(localVarOptionals.PlayMethod.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LiveStreamId.IsSet() {
		localVarQueryParams.Add("liveStreamId", parameterToString(localVarOptionals.LiveStreamId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PlaySessionId.IsSet() {
		localVarQueryParams.Add("playSessionId", parameterToString(localVarOptionals.PlaySessionId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RepeatMode.IsSet() {
		localVarQueryParams.Add("repeatMode", parameterToString(localVarOptionals.RepeatMode.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IsPaused.IsSet() {
		localVarQueryParams.Add("isPaused", parameterToString(localVarOptionals.IsPaused.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IsMuted.IsSet() {
		localVarQueryParams.Add("isMuted", parameterToString(localVarOptionals.IsMuted.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["X-Emby-Authorization"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

// OnPlaybackStartOpts Optional parameters for the method 'OnPlaybackStart'
type OnPlaybackStartOpts struct {
    MediaSourceId optional.String
    AudioStreamIndex optional.Int32
    SubtitleStreamIndex optional.Int32
    PlayMethod optional.Interface
    LiveStreamId optional.String
    PlaySessionId optional.String
    CanSeek optional.Bool
}

/*
OnPlaybackStart Reports that a user has begun playing an item.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param userId User id.
 * @param itemId Item id.
 * @param optional nil or *OnPlaybackStartOpts - Optional Parameters:
 * @param "MediaSourceId" (optional.String) -  The id of the MediaSource.
 * @param "AudioStreamIndex" (optional.Int32) -  The audio stream index.
 * @param "SubtitleStreamIndex" (optional.Int32) -  The subtitle stream index.
 * @param "PlayMethod" (optional.Interface of PlayMethod) -  The play method.
 * @param "LiveStreamId" (optional.String) -  The live stream id.
 * @param "PlaySessionId" (optional.String) -  The play session id.
 * @param "CanSeek" (optional.Bool) -  Indicates if the client can seek.
*/
func (a *PlaystateApiService) OnPlaybackStart(ctx _context.Context, userId string, itemId string, localVarOptionals *OnPlaybackStartOpts) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Users/{userId}/PlayingItems/{itemId}"
	localVarPath = strings.Replace(localVarPath, "{"+"userId"+"}", _neturl.QueryEscape(parameterToString(userId, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"itemId"+"}", _neturl.QueryEscape(parameterToString(itemId, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.MediaSourceId.IsSet() {
		localVarQueryParams.Add("mediaSourceId", parameterToString(localVarOptionals.MediaSourceId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AudioStreamIndex.IsSet() {
		localVarQueryParams.Add("audioStreamIndex", parameterToString(localVarOptionals.AudioStreamIndex.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SubtitleStreamIndex.IsSet() {
		localVarQueryParams.Add("subtitleStreamIndex", parameterToString(localVarOptionals.SubtitleStreamIndex.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PlayMethod.IsSet() {
		localVarQueryParams.Add("playMethod", parameterToString(localVarOptionals.PlayMethod.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LiveStreamId.IsSet() {
		localVarQueryParams.Add("liveStreamId", parameterToString(localVarOptionals.LiveStreamId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PlaySessionId.IsSet() {
		localVarQueryParams.Add("playSessionId", parameterToString(localVarOptionals.PlaySessionId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CanSeek.IsSet() {
		localVarQueryParams.Add("canSeek", parameterToString(localVarOptionals.CanSeek.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["X-Emby-Authorization"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

// OnPlaybackStoppedOpts Optional parameters for the method 'OnPlaybackStopped'
type OnPlaybackStoppedOpts struct {
    MediaSourceId optional.String
    NextMediaType optional.String
    PositionTicks optional.Int64
    LiveStreamId optional.String
    PlaySessionId optional.String
}

/*
OnPlaybackStopped Reports that a user has stopped playing an item.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param userId User id.
 * @param itemId Item id.
 * @param optional nil or *OnPlaybackStoppedOpts - Optional Parameters:
 * @param "MediaSourceId" (optional.String) -  The id of the MediaSource.
 * @param "NextMediaType" (optional.String) -  The next media type that will play.
 * @param "PositionTicks" (optional.Int64) -  Optional. The position, in ticks, where playback stopped. 1 tick = 10000 ms.
 * @param "LiveStreamId" (optional.String) -  The live stream id.
 * @param "PlaySessionId" (optional.String) -  The play session id.
*/
func (a *PlaystateApiService) OnPlaybackStopped(ctx _context.Context, userId string, itemId string, localVarOptionals *OnPlaybackStoppedOpts) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Users/{userId}/PlayingItems/{itemId}"
	localVarPath = strings.Replace(localVarPath, "{"+"userId"+"}", _neturl.QueryEscape(parameterToString(userId, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"itemId"+"}", _neturl.QueryEscape(parameterToString(itemId, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.MediaSourceId.IsSet() {
		localVarQueryParams.Add("mediaSourceId", parameterToString(localVarOptionals.MediaSourceId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NextMediaType.IsSet() {
		localVarQueryParams.Add("nextMediaType", parameterToString(localVarOptionals.NextMediaType.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PositionTicks.IsSet() {
		localVarQueryParams.Add("positionTicks", parameterToString(localVarOptionals.PositionTicks.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LiveStreamId.IsSet() {
		localVarQueryParams.Add("liveStreamId", parameterToString(localVarOptionals.LiveStreamId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PlaySessionId.IsSet() {
		localVarQueryParams.Add("playSessionId", parameterToString(localVarOptionals.PlaySessionId.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["X-Emby-Authorization"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

// PingPlaybackSessionOpts Optional parameters for the method 'PingPlaybackSession'
type PingPlaybackSessionOpts struct {
    PlaySessionId optional.String
}

/*
PingPlaybackSession Pings a playback session.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *PingPlaybackSessionOpts - Optional Parameters:
 * @param "PlaySessionId" (optional.String) -  Playback session id.
*/
func (a *PlaystateApiService) PingPlaybackSession(ctx _context.Context, localVarOptionals *PingPlaybackSessionOpts) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Sessions/Playing/Ping"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.PlaySessionId.IsSet() {
		localVarQueryParams.Add("playSessionId", parameterToString(localVarOptionals.PlaySessionId.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["X-Emby-Authorization"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

// ReportPlaybackProgressOpts Optional parameters for the method 'ReportPlaybackProgress'
type ReportPlaybackProgressOpts struct {
    PlaybackProgressInfo optional.Interface
}

/*
ReportPlaybackProgress Reports playback progress within a session.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *ReportPlaybackProgressOpts - Optional Parameters:
 * @param "PlaybackProgressInfo" (optional.Interface of PlaybackProgressInfo) -  The playback progress info.
*/
func (a *PlaystateApiService) ReportPlaybackProgress(ctx _context.Context, localVarOptionals *ReportPlaybackProgressOpts) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Sessions/Playing/Progress"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/json", "application/_*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.PlaybackProgressInfo.IsSet() {
		localVarOptionalPlaybackProgressInfo, localVarOptionalPlaybackProgressInfook := localVarOptionals.PlaybackProgressInfo.Value().(PlaybackProgressInfo)
		if !localVarOptionalPlaybackProgressInfook {
			return nil, reportError("playbackProgressInfo should be PlaybackProgressInfo")
		}
		localVarPostBody = &localVarOptionalPlaybackProgressInfo
	}

	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["X-Emby-Authorization"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

// ReportPlaybackStartOpts Optional parameters for the method 'ReportPlaybackStart'
type ReportPlaybackStartOpts struct {
    PlaybackStartInfo optional.Interface
}

/*
ReportPlaybackStart Reports playback has started within a session.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *ReportPlaybackStartOpts - Optional Parameters:
 * @param "PlaybackStartInfo" (optional.Interface of PlaybackStartInfo) -  The playback start info.
*/
func (a *PlaystateApiService) ReportPlaybackStart(ctx _context.Context, localVarOptionals *ReportPlaybackStartOpts) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Sessions/Playing"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/json", "application/_*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.PlaybackStartInfo.IsSet() {
		localVarOptionalPlaybackStartInfo, localVarOptionalPlaybackStartInfook := localVarOptionals.PlaybackStartInfo.Value().(PlaybackStartInfo)
		if !localVarOptionalPlaybackStartInfook {
			return nil, reportError("playbackStartInfo should be PlaybackStartInfo")
		}
		localVarPostBody = &localVarOptionalPlaybackStartInfo
	}

	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["X-Emby-Authorization"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

// ReportPlaybackStoppedOpts Optional parameters for the method 'ReportPlaybackStopped'
type ReportPlaybackStoppedOpts struct {
    PlaybackStopInfo optional.Interface
}

/*
ReportPlaybackStopped Reports playback has stopped within a session.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *ReportPlaybackStoppedOpts - Optional Parameters:
 * @param "PlaybackStopInfo" (optional.Interface of PlaybackStopInfo) -  The playback stop info.
*/
func (a *PlaystateApiService) ReportPlaybackStopped(ctx _context.Context, localVarOptionals *ReportPlaybackStoppedOpts) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Sessions/Playing/Stopped"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/json", "application/_*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.PlaybackStopInfo.IsSet() {
		localVarOptionalPlaybackStopInfo, localVarOptionalPlaybackStopInfook := localVarOptionals.PlaybackStopInfo.Value().(PlaybackStopInfo)
		if !localVarOptionalPlaybackStopInfook {
			return nil, reportError("playbackStopInfo should be PlaybackStopInfo")
		}
		localVarPostBody = &localVarOptionalPlaybackStopInfo
	}

	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["X-Emby-Authorization"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
