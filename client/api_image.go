/*
 * Jellyfin API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * API version: v1
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package client

import (
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
	"os"
	"github.com/antihax/optional"
)

// Linger please
var (
	_ _context.Context
)

// ImageApiService ImageApi service
type ImageApiService service

/*
DeleteItemImage Delete an item's image.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param itemId Item id.
 * @param imageType Image type.
 * @param imageIndex The image index.
*/
func (a *ImageApiService) DeleteItemImage(ctx _context.Context, itemId string, imageType ImageType, imageIndex int32) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Items/{itemId}/Images/{imageType}"
	localVarPath = strings.Replace(localVarPath, "{"+"itemId"+"}", _neturl.QueryEscape(parameterToString(itemId, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"imageType"+"}", _neturl.QueryEscape(parameterToString(imageType, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"imageIndex"+"}", _neturl.QueryEscape(parameterToString(imageIndex, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["X-Emby-Authorization"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

/*
DeleteItemImage2 Delete an item's image.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param itemId Item id.
 * @param imageType Image type.
 * @param imageIndex The image index.
*/
func (a *ImageApiService) DeleteItemImage2(ctx _context.Context, itemId string, imageType ImageType, imageIndex int32) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Items/{itemId}/Images/{imageType}/{imageIndex}"
	localVarPath = strings.Replace(localVarPath, "{"+"itemId"+"}", _neturl.QueryEscape(parameterToString(itemId, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"imageType"+"}", _neturl.QueryEscape(parameterToString(imageType, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"imageIndex"+"}", _neturl.QueryEscape(parameterToString(imageIndex, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["X-Emby-Authorization"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

/*
DeleteUserImage Delete the user's image.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param userId User Id.
 * @param imageType (Unused) Image type.
 * @param index (Unused) Image index.
 * @param itemType
*/
func (a *ImageApiService) DeleteUserImage(ctx _context.Context, userId string, imageType ImageType, index int32, itemType string) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Users/{userId}/Images/{itemType}"
	localVarPath = strings.Replace(localVarPath, "{"+"userId"+"}", _neturl.QueryEscape(parameterToString(userId, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"imageType"+"}", _neturl.QueryEscape(parameterToString(imageType, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", _neturl.QueryEscape(parameterToString(index, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"itemType"+"}", _neturl.QueryEscape(parameterToString(itemType, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["X-Emby-Authorization"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

/*
DeleteUserImage2 Delete the user's image.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param userId User Id.
 * @param imageType (Unused) Image type.
 * @param index (Unused) Image index.
 * @param itemType
*/
func (a *ImageApiService) DeleteUserImage2(ctx _context.Context, userId string, imageType ImageType, index int32, itemType string) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Users/{userId}/Images/{itemType}/{index}"
	localVarPath = strings.Replace(localVarPath, "{"+"userId"+"}", _neturl.QueryEscape(parameterToString(userId, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"imageType"+"}", _neturl.QueryEscape(parameterToString(imageType, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", _neturl.QueryEscape(parameterToString(index, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"itemType"+"}", _neturl.QueryEscape(parameterToString(itemType, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["X-Emby-Authorization"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

// GetArtistImageOpts Optional parameters for the method 'GetArtistImage'
type GetArtistImageOpts struct {
    Tag optional.String
    Format optional.Interface
    MaxWidth optional.Int32
    MaxHeight optional.Int32
    PercentPlayed optional.Float64
    UnplayedCount optional.Int32
    Width optional.Int32
    Height optional.Int32
    Quality optional.Int32
    CropWhitespace optional.Bool
    AddPlayedIndicator optional.Bool
    Blur optional.Int32
    BackgroundColor optional.String
    ForegroundLayer optional.String
}

/*
GetArtistImage Get artist image by name.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param name Artist name.
 * @param imageType Image type.
 * @param imageIndex Image index.
 * @param optional nil or *GetArtistImageOpts - Optional Parameters:
 * @param "Tag" (optional.String) -  Optional. Supply the cache tag from the item object to receive strong caching headers.
 * @param "Format" (optional.Interface of ImageFormat) -  Determines the output format of the image - original,gif,jpg,png.
 * @param "MaxWidth" (optional.Int32) -  The maximum image width to return.
 * @param "MaxHeight" (optional.Int32) -  The maximum image height to return.
 * @param "PercentPlayed" (optional.Float64) -  Optional. Percent to render for the percent played overlay.
 * @param "UnplayedCount" (optional.Int32) -  Optional. Unplayed count overlay to render.
 * @param "Width" (optional.Int32) -  The fixed image width to return.
 * @param "Height" (optional.Int32) -  The fixed image height to return.
 * @param "Quality" (optional.Int32) -  Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
 * @param "CropWhitespace" (optional.Bool) -  Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
 * @param "AddPlayedIndicator" (optional.Bool) -  Optional. Add a played indicator.
 * @param "Blur" (optional.Int32) -  Optional. Blur image.
 * @param "BackgroundColor" (optional.String) -  Optional. Apply a background color for transparent images.
 * @param "ForegroundLayer" (optional.String) -  Optional. Apply a foreground layer on top of the image.
@return *os.File
*/
func (a *ImageApiService) GetArtistImage(ctx _context.Context, name string, imageType ImageType, imageIndex int32, localVarOptionals *GetArtistImageOpts) (*os.File, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  *os.File
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Artists/{name}/Images/{imageType}/{imageIndex}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", _neturl.QueryEscape(parameterToString(name, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"imageType"+"}", _neturl.QueryEscape(parameterToString(imageType, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"imageIndex"+"}", _neturl.QueryEscape(parameterToString(imageIndex, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Tag.IsSet() {
		localVarQueryParams.Add("tag", parameterToString(localVarOptionals.Tag.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MaxWidth.IsSet() {
		localVarQueryParams.Add("maxWidth", parameterToString(localVarOptionals.MaxWidth.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MaxHeight.IsSet() {
		localVarQueryParams.Add("maxHeight", parameterToString(localVarOptionals.MaxHeight.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PercentPlayed.IsSet() {
		localVarQueryParams.Add("percentPlayed", parameterToString(localVarOptionals.PercentPlayed.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.UnplayedCount.IsSet() {
		localVarQueryParams.Add("unplayedCount", parameterToString(localVarOptionals.UnplayedCount.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Width.IsSet() {
		localVarQueryParams.Add("width", parameterToString(localVarOptionals.Width.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Height.IsSet() {
		localVarQueryParams.Add("height", parameterToString(localVarOptionals.Height.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Quality.IsSet() {
		localVarQueryParams.Add("quality", parameterToString(localVarOptionals.Quality.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CropWhitespace.IsSet() {
		localVarQueryParams.Add("cropWhitespace", parameterToString(localVarOptionals.CropWhitespace.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AddPlayedIndicator.IsSet() {
		localVarQueryParams.Add("addPlayedIndicator", parameterToString(localVarOptionals.AddPlayedIndicator.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Blur.IsSet() {
		localVarQueryParams.Add("blur", parameterToString(localVarOptionals.Blur.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.BackgroundColor.IsSet() {
		localVarQueryParams.Add("backgroundColor", parameterToString(localVarOptionals.BackgroundColor.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ForegroundLayer.IsSet() {
		localVarQueryParams.Add("foregroundLayer", parameterToString(localVarOptionals.ForegroundLayer.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"image/_*", "application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["X-Emby-Authorization"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// GetGenreImageOpts Optional parameters for the method 'GetGenreImage'
type GetGenreImageOpts struct {
    Tag optional.String
    Format optional.Interface
    MaxWidth optional.Int32
    MaxHeight optional.Int32
    PercentPlayed optional.Float64
    UnplayedCount optional.Int32
    Width optional.Int32
    Height optional.Int32
    Quality optional.Int32
    CropWhitespace optional.Bool
    AddPlayedIndicator optional.Bool
    Blur optional.Int32
    BackgroundColor optional.String
    ForegroundLayer optional.String
}

/*
GetGenreImage Get genre image by name.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param name Genre name.
 * @param imageType Image type.
 * @param imageIndex Image index.
 * @param optional nil or *GetGenreImageOpts - Optional Parameters:
 * @param "Tag" (optional.String) -  Optional. Supply the cache tag from the item object to receive strong caching headers.
 * @param "Format" (optional.Interface of ImageFormat) -  Determines the output format of the image - original,gif,jpg,png.
 * @param "MaxWidth" (optional.Int32) -  The maximum image width to return.
 * @param "MaxHeight" (optional.Int32) -  The maximum image height to return.
 * @param "PercentPlayed" (optional.Float64) -  Optional. Percent to render for the percent played overlay.
 * @param "UnplayedCount" (optional.Int32) -  Optional. Unplayed count overlay to render.
 * @param "Width" (optional.Int32) -  The fixed image width to return.
 * @param "Height" (optional.Int32) -  The fixed image height to return.
 * @param "Quality" (optional.Int32) -  Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
 * @param "CropWhitespace" (optional.Bool) -  Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
 * @param "AddPlayedIndicator" (optional.Bool) -  Optional. Add a played indicator.
 * @param "Blur" (optional.Int32) -  Optional. Blur image.
 * @param "BackgroundColor" (optional.String) -  Optional. Apply a background color for transparent images.
 * @param "ForegroundLayer" (optional.String) -  Optional. Apply a foreground layer on top of the image.
@return *os.File
*/
func (a *ImageApiService) GetGenreImage(ctx _context.Context, name string, imageType ImageType, imageIndex int32, localVarOptionals *GetGenreImageOpts) (*os.File, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  *os.File
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Genres/{name}/Images/{imageType}/{imageIndex}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", _neturl.QueryEscape(parameterToString(name, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"imageType"+"}", _neturl.QueryEscape(parameterToString(imageType, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"imageIndex"+"}", _neturl.QueryEscape(parameterToString(imageIndex, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Tag.IsSet() {
		localVarQueryParams.Add("tag", parameterToString(localVarOptionals.Tag.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MaxWidth.IsSet() {
		localVarQueryParams.Add("maxWidth", parameterToString(localVarOptionals.MaxWidth.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MaxHeight.IsSet() {
		localVarQueryParams.Add("maxHeight", parameterToString(localVarOptionals.MaxHeight.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PercentPlayed.IsSet() {
		localVarQueryParams.Add("percentPlayed", parameterToString(localVarOptionals.PercentPlayed.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.UnplayedCount.IsSet() {
		localVarQueryParams.Add("unplayedCount", parameterToString(localVarOptionals.UnplayedCount.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Width.IsSet() {
		localVarQueryParams.Add("width", parameterToString(localVarOptionals.Width.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Height.IsSet() {
		localVarQueryParams.Add("height", parameterToString(localVarOptionals.Height.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Quality.IsSet() {
		localVarQueryParams.Add("quality", parameterToString(localVarOptionals.Quality.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CropWhitespace.IsSet() {
		localVarQueryParams.Add("cropWhitespace", parameterToString(localVarOptionals.CropWhitespace.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AddPlayedIndicator.IsSet() {
		localVarQueryParams.Add("addPlayedIndicator", parameterToString(localVarOptionals.AddPlayedIndicator.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Blur.IsSet() {
		localVarQueryParams.Add("blur", parameterToString(localVarOptionals.Blur.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.BackgroundColor.IsSet() {
		localVarQueryParams.Add("backgroundColor", parameterToString(localVarOptionals.BackgroundColor.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ForegroundLayer.IsSet() {
		localVarQueryParams.Add("foregroundLayer", parameterToString(localVarOptionals.ForegroundLayer.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"image/_*", "application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["X-Emby-Authorization"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// GetItemImageOpts Optional parameters for the method 'GetItemImage'
type GetItemImageOpts struct {
    MaxWidth optional.Int32
    MaxHeight optional.Int32
    Width optional.Int32
    Height optional.Int32
    Quality optional.Int32
    Tag optional.String
    CropWhitespace optional.Bool
    Format optional.Interface
    AddPlayedIndicator optional.Bool
    PercentPlayed optional.Float64
    UnplayedCount optional.Int32
    Blur optional.Int32
    BackgroundColor optional.String
    ForegroundLayer optional.String
}

/*
GetItemImage Gets the item's image.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param itemId Item id.
 * @param imageType Image type.
 * @param imageIndex Image index.
 * @param optional nil or *GetItemImageOpts - Optional Parameters:
 * @param "MaxWidth" (optional.Int32) -  The maximum image width to return.
 * @param "MaxHeight" (optional.Int32) -  The maximum image height to return.
 * @param "Width" (optional.Int32) -  The fixed image width to return.
 * @param "Height" (optional.Int32) -  The fixed image height to return.
 * @param "Quality" (optional.Int32) -  Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
 * @param "Tag" (optional.String) -  Optional. Supply the cache tag from the item object to receive strong caching headers.
 * @param "CropWhitespace" (optional.Bool) -  Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
 * @param "Format" (optional.Interface of ImageFormat) -  Optional. The MediaBrowser.Model.Drawing.ImageFormat of the returned image.
 * @param "AddPlayedIndicator" (optional.Bool) -  Optional. Add a played indicator.
 * @param "PercentPlayed" (optional.Float64) -  Optional. Percent to render for the percent played overlay.
 * @param "UnplayedCount" (optional.Int32) -  Optional. Unplayed count overlay to render.
 * @param "Blur" (optional.Int32) -  Optional. Blur image.
 * @param "BackgroundColor" (optional.String) -  Optional. Apply a background color for transparent images.
 * @param "ForegroundLayer" (optional.String) -  Optional. Apply a foreground layer on top of the image.
@return *os.File
*/
func (a *ImageApiService) GetItemImage(ctx _context.Context, itemId string, imageType ImageType, imageIndex int32, localVarOptionals *GetItemImageOpts) (*os.File, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  *os.File
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Items/{itemId}/Images/{imageType}"
	localVarPath = strings.Replace(localVarPath, "{"+"itemId"+"}", _neturl.QueryEscape(parameterToString(itemId, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"imageType"+"}", _neturl.QueryEscape(parameterToString(imageType, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"imageIndex"+"}", _neturl.QueryEscape(parameterToString(imageIndex, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.MaxWidth.IsSet() {
		localVarQueryParams.Add("maxWidth", parameterToString(localVarOptionals.MaxWidth.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MaxHeight.IsSet() {
		localVarQueryParams.Add("maxHeight", parameterToString(localVarOptionals.MaxHeight.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Width.IsSet() {
		localVarQueryParams.Add("width", parameterToString(localVarOptionals.Width.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Height.IsSet() {
		localVarQueryParams.Add("height", parameterToString(localVarOptionals.Height.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Quality.IsSet() {
		localVarQueryParams.Add("quality", parameterToString(localVarOptionals.Quality.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Tag.IsSet() {
		localVarQueryParams.Add("tag", parameterToString(localVarOptionals.Tag.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CropWhitespace.IsSet() {
		localVarQueryParams.Add("cropWhitespace", parameterToString(localVarOptionals.CropWhitespace.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AddPlayedIndicator.IsSet() {
		localVarQueryParams.Add("addPlayedIndicator", parameterToString(localVarOptionals.AddPlayedIndicator.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PercentPlayed.IsSet() {
		localVarQueryParams.Add("percentPlayed", parameterToString(localVarOptionals.PercentPlayed.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.UnplayedCount.IsSet() {
		localVarQueryParams.Add("unplayedCount", parameterToString(localVarOptionals.UnplayedCount.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Blur.IsSet() {
		localVarQueryParams.Add("blur", parameterToString(localVarOptionals.Blur.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.BackgroundColor.IsSet() {
		localVarQueryParams.Add("backgroundColor", parameterToString(localVarOptionals.BackgroundColor.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ForegroundLayer.IsSet() {
		localVarQueryParams.Add("foregroundLayer", parameterToString(localVarOptionals.ForegroundLayer.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"image/_*", "application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["X-Emby-Authorization"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// GetItemImage2Opts Optional parameters for the method 'GetItemImage2'
type GetItemImage2Opts struct {
    MaxWidth optional.Int32
    MaxHeight optional.Int32
    Width optional.Int32
    Height optional.Int32
    Quality optional.Int32
    Tag optional.String
    CropWhitespace optional.Bool
    Format optional.Interface
    AddPlayedIndicator optional.Bool
    PercentPlayed optional.Float64
    UnplayedCount optional.Int32
    Blur optional.Int32
    BackgroundColor optional.String
    ForegroundLayer optional.String
}

/*
GetItemImage2 Gets the item's image.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param itemId Item id.
 * @param imageType Image type.
 * @param imageIndex Image index.
 * @param optional nil or *GetItemImage2Opts - Optional Parameters:
 * @param "MaxWidth" (optional.Int32) -  The maximum image width to return.
 * @param "MaxHeight" (optional.Int32) -  The maximum image height to return.
 * @param "Width" (optional.Int32) -  The fixed image width to return.
 * @param "Height" (optional.Int32) -  The fixed image height to return.
 * @param "Quality" (optional.Int32) -  Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
 * @param "Tag" (optional.String) -  Optional. Supply the cache tag from the item object to receive strong caching headers.
 * @param "CropWhitespace" (optional.Bool) -  Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
 * @param "Format" (optional.Interface of ImageFormat) -  Optional. The MediaBrowser.Model.Drawing.ImageFormat of the returned image.
 * @param "AddPlayedIndicator" (optional.Bool) -  Optional. Add a played indicator.
 * @param "PercentPlayed" (optional.Float64) -  Optional. Percent to render for the percent played overlay.
 * @param "UnplayedCount" (optional.Int32) -  Optional. Unplayed count overlay to render.
 * @param "Blur" (optional.Int32) -  Optional. Blur image.
 * @param "BackgroundColor" (optional.String) -  Optional. Apply a background color for transparent images.
 * @param "ForegroundLayer" (optional.String) -  Optional. Apply a foreground layer on top of the image.
@return *os.File
*/
func (a *ImageApiService) GetItemImage2(ctx _context.Context, itemId string, imageType ImageType, imageIndex int32, localVarOptionals *GetItemImage2Opts) (*os.File, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  *os.File
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Items/{itemId}/Images/{imageType}/{imageIndex}"
	localVarPath = strings.Replace(localVarPath, "{"+"itemId"+"}", _neturl.QueryEscape(parameterToString(itemId, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"imageType"+"}", _neturl.QueryEscape(parameterToString(imageType, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"imageIndex"+"}", _neturl.QueryEscape(parameterToString(imageIndex, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.MaxWidth.IsSet() {
		localVarQueryParams.Add("maxWidth", parameterToString(localVarOptionals.MaxWidth.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MaxHeight.IsSet() {
		localVarQueryParams.Add("maxHeight", parameterToString(localVarOptionals.MaxHeight.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Width.IsSet() {
		localVarQueryParams.Add("width", parameterToString(localVarOptionals.Width.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Height.IsSet() {
		localVarQueryParams.Add("height", parameterToString(localVarOptionals.Height.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Quality.IsSet() {
		localVarQueryParams.Add("quality", parameterToString(localVarOptionals.Quality.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Tag.IsSet() {
		localVarQueryParams.Add("tag", parameterToString(localVarOptionals.Tag.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CropWhitespace.IsSet() {
		localVarQueryParams.Add("cropWhitespace", parameterToString(localVarOptionals.CropWhitespace.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AddPlayedIndicator.IsSet() {
		localVarQueryParams.Add("addPlayedIndicator", parameterToString(localVarOptionals.AddPlayedIndicator.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PercentPlayed.IsSet() {
		localVarQueryParams.Add("percentPlayed", parameterToString(localVarOptionals.PercentPlayed.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.UnplayedCount.IsSet() {
		localVarQueryParams.Add("unplayedCount", parameterToString(localVarOptionals.UnplayedCount.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Blur.IsSet() {
		localVarQueryParams.Add("blur", parameterToString(localVarOptionals.Blur.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.BackgroundColor.IsSet() {
		localVarQueryParams.Add("backgroundColor", parameterToString(localVarOptionals.BackgroundColor.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ForegroundLayer.IsSet() {
		localVarQueryParams.Add("foregroundLayer", parameterToString(localVarOptionals.ForegroundLayer.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"image/_*", "application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["X-Emby-Authorization"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// GetItemImage2_1Opts Optional parameters for the method 'GetItemImage2_1'
type GetItemImage2_1Opts struct {
    Width optional.Int32
    Height optional.Int32
    Quality optional.Int32
    CropWhitespace optional.Bool
    AddPlayedIndicator optional.Bool
    Blur optional.Int32
    BackgroundColor optional.String
    ForegroundLayer optional.String
}

/*
GetItemImage2_0 Gets the item's image.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param itemId Item id.
 * @param imageType Image type.
 * @param maxWidth The maximum image width to return.
 * @param maxHeight The maximum image height to return.
 * @param tag Optional. Supply the cache tag from the item object to receive strong caching headers.
 * @param format Determines the output format of the image - original,gif,jpg,png.
 * @param percentPlayed Optional. Percent to render for the percent played overlay.
 * @param unplayedCount Optional. Unplayed count overlay to render.
 * @param imageIndex Image index.
 * @param optional nil or *GetItemImage2_1Opts - Optional Parameters:
 * @param "Width" (optional.Int32) -  The fixed image width to return.
 * @param "Height" (optional.Int32) -  The fixed image height to return.
 * @param "Quality" (optional.Int32) -  Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
 * @param "CropWhitespace" (optional.Bool) -  Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
 * @param "AddPlayedIndicator" (optional.Bool) -  Optional. Add a played indicator.
 * @param "Blur" (optional.Int32) -  Optional. Blur image.
 * @param "BackgroundColor" (optional.String) -  Optional. Apply a background color for transparent images.
 * @param "ForegroundLayer" (optional.String) -  Optional. Apply a foreground layer on top of the image.
@return *os.File
*/
func (a *ImageApiService) GetItemImage2_1(ctx _context.Context, itemId string, imageType ImageType, maxWidth int32, maxHeight int32, tag string, format ImageFormat, percentPlayed float64, unplayedCount int32, imageIndex int32, localVarOptionals *GetItemImage2_1Opts) (*os.File, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  *os.File
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Items/{itemId}/Images/{imageType}/{imageIndex}/{tag}/{format}/{maxWidth}/{maxHeight}/{percentPlayed}/{unplayedCount}"
	localVarPath = strings.Replace(localVarPath, "{"+"itemId"+"}", _neturl.QueryEscape(parameterToString(itemId, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"imageType"+"}", _neturl.QueryEscape(parameterToString(imageType, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"maxWidth"+"}", _neturl.QueryEscape(parameterToString(maxWidth, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"maxHeight"+"}", _neturl.QueryEscape(parameterToString(maxHeight, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"tag"+"}", _neturl.QueryEscape(parameterToString(tag, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"format"+"}", _neturl.QueryEscape(parameterToString(format, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"percentPlayed"+"}", _neturl.QueryEscape(parameterToString(percentPlayed, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"unplayedCount"+"}", _neturl.QueryEscape(parameterToString(unplayedCount, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"imageIndex"+"}", _neturl.QueryEscape(parameterToString(imageIndex, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Width.IsSet() {
		localVarQueryParams.Add("width", parameterToString(localVarOptionals.Width.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Height.IsSet() {
		localVarQueryParams.Add("height", parameterToString(localVarOptionals.Height.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Quality.IsSet() {
		localVarQueryParams.Add("quality", parameterToString(localVarOptionals.Quality.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CropWhitespace.IsSet() {
		localVarQueryParams.Add("cropWhitespace", parameterToString(localVarOptionals.CropWhitespace.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AddPlayedIndicator.IsSet() {
		localVarQueryParams.Add("addPlayedIndicator", parameterToString(localVarOptionals.AddPlayedIndicator.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Blur.IsSet() {
		localVarQueryParams.Add("blur", parameterToString(localVarOptionals.Blur.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.BackgroundColor.IsSet() {
		localVarQueryParams.Add("backgroundColor", parameterToString(localVarOptionals.BackgroundColor.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ForegroundLayer.IsSet() {
		localVarQueryParams.Add("foregroundLayer", parameterToString(localVarOptionals.ForegroundLayer.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"image/_*", "application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["X-Emby-Authorization"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
GetItemImageInfos Get item image infos.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param itemId Item id.
@return []ImageInfo
*/
func (a *ImageApiService) GetItemImageInfos(ctx _context.Context, itemId string) ([]ImageInfo, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []ImageInfo
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Items/{itemId}/Images"
	localVarPath = strings.Replace(localVarPath, "{"+"itemId"+"}", _neturl.QueryEscape(parameterToString(itemId, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["X-Emby-Authorization"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// GetMusicGenreImageOpts Optional parameters for the method 'GetMusicGenreImage'
type GetMusicGenreImageOpts struct {
    Tag optional.String
    Format optional.Interface
    MaxWidth optional.Int32
    MaxHeight optional.Int32
    PercentPlayed optional.Float64
    UnplayedCount optional.Int32
    Width optional.Int32
    Height optional.Int32
    Quality optional.Int32
    CropWhitespace optional.Bool
    AddPlayedIndicator optional.Bool
    Blur optional.Int32
    BackgroundColor optional.String
    ForegroundLayer optional.String
}

/*
GetMusicGenreImage Get music genre image by name.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param name Music genre name.
 * @param imageType Image type.
 * @param imageIndex Image index.
 * @param optional nil or *GetMusicGenreImageOpts - Optional Parameters:
 * @param "Tag" (optional.String) -  Optional. Supply the cache tag from the item object to receive strong caching headers.
 * @param "Format" (optional.Interface of ImageFormat) -  Determines the output format of the image - original,gif,jpg,png.
 * @param "MaxWidth" (optional.Int32) -  The maximum image width to return.
 * @param "MaxHeight" (optional.Int32) -  The maximum image height to return.
 * @param "PercentPlayed" (optional.Float64) -  Optional. Percent to render for the percent played overlay.
 * @param "UnplayedCount" (optional.Int32) -  Optional. Unplayed count overlay to render.
 * @param "Width" (optional.Int32) -  The fixed image width to return.
 * @param "Height" (optional.Int32) -  The fixed image height to return.
 * @param "Quality" (optional.Int32) -  Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
 * @param "CropWhitespace" (optional.Bool) -  Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
 * @param "AddPlayedIndicator" (optional.Bool) -  Optional. Add a played indicator.
 * @param "Blur" (optional.Int32) -  Optional. Blur image.
 * @param "BackgroundColor" (optional.String) -  Optional. Apply a background color for transparent images.
 * @param "ForegroundLayer" (optional.String) -  Optional. Apply a foreground layer on top of the image.
@return *os.File
*/
func (a *ImageApiService) GetMusicGenreImage(ctx _context.Context, name string, imageType ImageType, imageIndex int32, localVarOptionals *GetMusicGenreImageOpts) (*os.File, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  *os.File
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/MusicGenres/{name}/Images/{imageType}/{imageIndex}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", _neturl.QueryEscape(parameterToString(name, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"imageType"+"}", _neturl.QueryEscape(parameterToString(imageType, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"imageIndex"+"}", _neturl.QueryEscape(parameterToString(imageIndex, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Tag.IsSet() {
		localVarQueryParams.Add("tag", parameterToString(localVarOptionals.Tag.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MaxWidth.IsSet() {
		localVarQueryParams.Add("maxWidth", parameterToString(localVarOptionals.MaxWidth.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MaxHeight.IsSet() {
		localVarQueryParams.Add("maxHeight", parameterToString(localVarOptionals.MaxHeight.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PercentPlayed.IsSet() {
		localVarQueryParams.Add("percentPlayed", parameterToString(localVarOptionals.PercentPlayed.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.UnplayedCount.IsSet() {
		localVarQueryParams.Add("unplayedCount", parameterToString(localVarOptionals.UnplayedCount.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Width.IsSet() {
		localVarQueryParams.Add("width", parameterToString(localVarOptionals.Width.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Height.IsSet() {
		localVarQueryParams.Add("height", parameterToString(localVarOptionals.Height.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Quality.IsSet() {
		localVarQueryParams.Add("quality", parameterToString(localVarOptionals.Quality.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CropWhitespace.IsSet() {
		localVarQueryParams.Add("cropWhitespace", parameterToString(localVarOptionals.CropWhitespace.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AddPlayedIndicator.IsSet() {
		localVarQueryParams.Add("addPlayedIndicator", parameterToString(localVarOptionals.AddPlayedIndicator.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Blur.IsSet() {
		localVarQueryParams.Add("blur", parameterToString(localVarOptionals.Blur.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.BackgroundColor.IsSet() {
		localVarQueryParams.Add("backgroundColor", parameterToString(localVarOptionals.BackgroundColor.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ForegroundLayer.IsSet() {
		localVarQueryParams.Add("foregroundLayer", parameterToString(localVarOptionals.ForegroundLayer.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"image/_*", "application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["X-Emby-Authorization"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// GetPersonImageOpts Optional parameters for the method 'GetPersonImage'
type GetPersonImageOpts struct {
    Tag optional.String
    Format optional.Interface
    MaxWidth optional.Int32
    MaxHeight optional.Int32
    PercentPlayed optional.Float64
    UnplayedCount optional.Int32
    Width optional.Int32
    Height optional.Int32
    Quality optional.Int32
    CropWhitespace optional.Bool
    AddPlayedIndicator optional.Bool
    Blur optional.Int32
    BackgroundColor optional.String
    ForegroundLayer optional.String
}

/*
GetPersonImage Get person image by name.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param name Person name.
 * @param imageType Image type.
 * @param imageIndex Image index.
 * @param optional nil or *GetPersonImageOpts - Optional Parameters:
 * @param "Tag" (optional.String) -  Optional. Supply the cache tag from the item object to receive strong caching headers.
 * @param "Format" (optional.Interface of ImageFormat) -  Determines the output format of the image - original,gif,jpg,png.
 * @param "MaxWidth" (optional.Int32) -  The maximum image width to return.
 * @param "MaxHeight" (optional.Int32) -  The maximum image height to return.
 * @param "PercentPlayed" (optional.Float64) -  Optional. Percent to render for the percent played overlay.
 * @param "UnplayedCount" (optional.Int32) -  Optional. Unplayed count overlay to render.
 * @param "Width" (optional.Int32) -  The fixed image width to return.
 * @param "Height" (optional.Int32) -  The fixed image height to return.
 * @param "Quality" (optional.Int32) -  Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
 * @param "CropWhitespace" (optional.Bool) -  Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
 * @param "AddPlayedIndicator" (optional.Bool) -  Optional. Add a played indicator.
 * @param "Blur" (optional.Int32) -  Optional. Blur image.
 * @param "BackgroundColor" (optional.String) -  Optional. Apply a background color for transparent images.
 * @param "ForegroundLayer" (optional.String) -  Optional. Apply a foreground layer on top of the image.
@return *os.File
*/
func (a *ImageApiService) GetPersonImage(ctx _context.Context, name string, imageType ImageType, imageIndex int32, localVarOptionals *GetPersonImageOpts) (*os.File, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  *os.File
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Persons/{name}/Images/{imageType}/{imageIndex}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", _neturl.QueryEscape(parameterToString(name, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"imageType"+"}", _neturl.QueryEscape(parameterToString(imageType, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"imageIndex"+"}", _neturl.QueryEscape(parameterToString(imageIndex, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Tag.IsSet() {
		localVarQueryParams.Add("tag", parameterToString(localVarOptionals.Tag.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MaxWidth.IsSet() {
		localVarQueryParams.Add("maxWidth", parameterToString(localVarOptionals.MaxWidth.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MaxHeight.IsSet() {
		localVarQueryParams.Add("maxHeight", parameterToString(localVarOptionals.MaxHeight.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PercentPlayed.IsSet() {
		localVarQueryParams.Add("percentPlayed", parameterToString(localVarOptionals.PercentPlayed.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.UnplayedCount.IsSet() {
		localVarQueryParams.Add("unplayedCount", parameterToString(localVarOptionals.UnplayedCount.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Width.IsSet() {
		localVarQueryParams.Add("width", parameterToString(localVarOptionals.Width.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Height.IsSet() {
		localVarQueryParams.Add("height", parameterToString(localVarOptionals.Height.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Quality.IsSet() {
		localVarQueryParams.Add("quality", parameterToString(localVarOptionals.Quality.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CropWhitespace.IsSet() {
		localVarQueryParams.Add("cropWhitespace", parameterToString(localVarOptionals.CropWhitespace.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AddPlayedIndicator.IsSet() {
		localVarQueryParams.Add("addPlayedIndicator", parameterToString(localVarOptionals.AddPlayedIndicator.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Blur.IsSet() {
		localVarQueryParams.Add("blur", parameterToString(localVarOptionals.Blur.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.BackgroundColor.IsSet() {
		localVarQueryParams.Add("backgroundColor", parameterToString(localVarOptionals.BackgroundColor.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ForegroundLayer.IsSet() {
		localVarQueryParams.Add("foregroundLayer", parameterToString(localVarOptionals.ForegroundLayer.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"image/_*", "application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["X-Emby-Authorization"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// GetStudioImageOpts Optional parameters for the method 'GetStudioImage'
type GetStudioImageOpts struct {
    MaxWidth optional.Int32
    MaxHeight optional.Int32
    PercentPlayed optional.Float64
    UnplayedCount optional.Int32
    Width optional.Int32
    Height optional.Int32
    Quality optional.Int32
    CropWhitespace optional.Bool
    AddPlayedIndicator optional.Bool
    Blur optional.Int32
    BackgroundColor optional.String
    ForegroundLayer optional.String
}

/*
GetStudioImage Get studio image by name.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param name Studio name.
 * @param imageType Image type.
 * @param tag Optional. Supply the cache tag from the item object to receive strong caching headers.
 * @param format Determines the output format of the image - original,gif,jpg,png.
 * @param imageIndex Image index.
 * @param optional nil or *GetStudioImageOpts - Optional Parameters:
 * @param "MaxWidth" (optional.Int32) -  The maximum image width to return.
 * @param "MaxHeight" (optional.Int32) -  The maximum image height to return.
 * @param "PercentPlayed" (optional.Float64) -  Optional. Percent to render for the percent played overlay.
 * @param "UnplayedCount" (optional.Int32) -  Optional. Unplayed count overlay to render.
 * @param "Width" (optional.Int32) -  The fixed image width to return.
 * @param "Height" (optional.Int32) -  The fixed image height to return.
 * @param "Quality" (optional.Int32) -  Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
 * @param "CropWhitespace" (optional.Bool) -  Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
 * @param "AddPlayedIndicator" (optional.Bool) -  Optional. Add a played indicator.
 * @param "Blur" (optional.Int32) -  Optional. Blur image.
 * @param "BackgroundColor" (optional.String) -  Optional. Apply a background color for transparent images.
 * @param "ForegroundLayer" (optional.String) -  Optional. Apply a foreground layer on top of the image.
@return *os.File
*/
func (a *ImageApiService) GetStudioImage(ctx _context.Context, name string, imageType ImageType, tag string, format ImageFormat, imageIndex int32, localVarOptionals *GetStudioImageOpts) (*os.File, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  *os.File
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Studios/{name}/Images/{imageType}/{imageIndex}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", _neturl.QueryEscape(parameterToString(name, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"imageType"+"}", _neturl.QueryEscape(parameterToString(imageType, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"tag"+"}", _neturl.QueryEscape(parameterToString(tag, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"format"+"}", _neturl.QueryEscape(parameterToString(format, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"imageIndex"+"}", _neturl.QueryEscape(parameterToString(imageIndex, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.MaxWidth.IsSet() {
		localVarQueryParams.Add("maxWidth", parameterToString(localVarOptionals.MaxWidth.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MaxHeight.IsSet() {
		localVarQueryParams.Add("maxHeight", parameterToString(localVarOptionals.MaxHeight.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PercentPlayed.IsSet() {
		localVarQueryParams.Add("percentPlayed", parameterToString(localVarOptionals.PercentPlayed.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.UnplayedCount.IsSet() {
		localVarQueryParams.Add("unplayedCount", parameterToString(localVarOptionals.UnplayedCount.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Width.IsSet() {
		localVarQueryParams.Add("width", parameterToString(localVarOptionals.Width.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Height.IsSet() {
		localVarQueryParams.Add("height", parameterToString(localVarOptionals.Height.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Quality.IsSet() {
		localVarQueryParams.Add("quality", parameterToString(localVarOptionals.Quality.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CropWhitespace.IsSet() {
		localVarQueryParams.Add("cropWhitespace", parameterToString(localVarOptionals.CropWhitespace.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AddPlayedIndicator.IsSet() {
		localVarQueryParams.Add("addPlayedIndicator", parameterToString(localVarOptionals.AddPlayedIndicator.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Blur.IsSet() {
		localVarQueryParams.Add("blur", parameterToString(localVarOptionals.Blur.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.BackgroundColor.IsSet() {
		localVarQueryParams.Add("backgroundColor", parameterToString(localVarOptionals.BackgroundColor.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ForegroundLayer.IsSet() {
		localVarQueryParams.Add("foregroundLayer", parameterToString(localVarOptionals.ForegroundLayer.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"image/_*", "application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["X-Emby-Authorization"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// GetUserImageOpts Optional parameters for the method 'GetUserImage'
type GetUserImageOpts struct {
    Tag optional.String
    Format optional.Interface
    MaxWidth optional.Int32
    MaxHeight optional.Int32
    PercentPlayed optional.Float64
    UnplayedCount optional.Int32
    Width optional.Int32
    Height optional.Int32
    Quality optional.Int32
    CropWhitespace optional.Bool
    AddPlayedIndicator optional.Bool
    Blur optional.Int32
    BackgroundColor optional.String
    ForegroundLayer optional.String
}

/*
GetUserImage Get user profile image.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param userId User id.
 * @param imageType Image type.
 * @param imageIndex Image index.
 * @param optional nil or *GetUserImageOpts - Optional Parameters:
 * @param "Tag" (optional.String) -  Optional. Supply the cache tag from the item object to receive strong caching headers.
 * @param "Format" (optional.Interface of ImageFormat) -  Determines the output format of the image - original,gif,jpg,png.
 * @param "MaxWidth" (optional.Int32) -  The maximum image width to return.
 * @param "MaxHeight" (optional.Int32) -  The maximum image height to return.
 * @param "PercentPlayed" (optional.Float64) -  Optional. Percent to render for the percent played overlay.
 * @param "UnplayedCount" (optional.Int32) -  Optional. Unplayed count overlay to render.
 * @param "Width" (optional.Int32) -  The fixed image width to return.
 * @param "Height" (optional.Int32) -  The fixed image height to return.
 * @param "Quality" (optional.Int32) -  Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
 * @param "CropWhitespace" (optional.Bool) -  Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
 * @param "AddPlayedIndicator" (optional.Bool) -  Optional. Add a played indicator.
 * @param "Blur" (optional.Int32) -  Optional. Blur image.
 * @param "BackgroundColor" (optional.String) -  Optional. Apply a background color for transparent images.
 * @param "ForegroundLayer" (optional.String) -  Optional. Apply a foreground layer on top of the image.
@return *os.File
*/
func (a *ImageApiService) GetUserImage(ctx _context.Context, userId string, imageType ImageType, imageIndex int32, localVarOptionals *GetUserImageOpts) (*os.File, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  *os.File
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Users/{userId}/Images/{imageType}/{imageIndex}"
	localVarPath = strings.Replace(localVarPath, "{"+"userId"+"}", _neturl.QueryEscape(parameterToString(userId, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"imageType"+"}", _neturl.QueryEscape(parameterToString(imageType, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"imageIndex"+"}", _neturl.QueryEscape(parameterToString(imageIndex, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Tag.IsSet() {
		localVarQueryParams.Add("tag", parameterToString(localVarOptionals.Tag.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MaxWidth.IsSet() {
		localVarQueryParams.Add("maxWidth", parameterToString(localVarOptionals.MaxWidth.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MaxHeight.IsSet() {
		localVarQueryParams.Add("maxHeight", parameterToString(localVarOptionals.MaxHeight.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PercentPlayed.IsSet() {
		localVarQueryParams.Add("percentPlayed", parameterToString(localVarOptionals.PercentPlayed.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.UnplayedCount.IsSet() {
		localVarQueryParams.Add("unplayedCount", parameterToString(localVarOptionals.UnplayedCount.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Width.IsSet() {
		localVarQueryParams.Add("width", parameterToString(localVarOptionals.Width.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Height.IsSet() {
		localVarQueryParams.Add("height", parameterToString(localVarOptionals.Height.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Quality.IsSet() {
		localVarQueryParams.Add("quality", parameterToString(localVarOptionals.Quality.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CropWhitespace.IsSet() {
		localVarQueryParams.Add("cropWhitespace", parameterToString(localVarOptionals.CropWhitespace.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AddPlayedIndicator.IsSet() {
		localVarQueryParams.Add("addPlayedIndicator", parameterToString(localVarOptionals.AddPlayedIndicator.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Blur.IsSet() {
		localVarQueryParams.Add("blur", parameterToString(localVarOptionals.Blur.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.BackgroundColor.IsSet() {
		localVarQueryParams.Add("backgroundColor", parameterToString(localVarOptionals.BackgroundColor.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ForegroundLayer.IsSet() {
		localVarQueryParams.Add("foregroundLayer", parameterToString(localVarOptionals.ForegroundLayer.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"image/_*", "application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["X-Emby-Authorization"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// HeadArtistImageOpts Optional parameters for the method 'HeadArtistImage'
type HeadArtistImageOpts struct {
    Tag optional.String
    Format optional.Interface
    MaxWidth optional.Int32
    MaxHeight optional.Int32
    PercentPlayed optional.Float64
    UnplayedCount optional.Int32
    Width optional.Int32
    Height optional.Int32
    Quality optional.Int32
    CropWhitespace optional.Bool
    AddPlayedIndicator optional.Bool
    Blur optional.Int32
    BackgroundColor optional.String
    ForegroundLayer optional.String
}

/*
HeadArtistImage Get artist image by name.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param name Artist name.
 * @param imageType Image type.
 * @param imageIndex Image index.
 * @param optional nil or *HeadArtistImageOpts - Optional Parameters:
 * @param "Tag" (optional.String) -  Optional. Supply the cache tag from the item object to receive strong caching headers.
 * @param "Format" (optional.Interface of ImageFormat) -  Determines the output format of the image - original,gif,jpg,png.
 * @param "MaxWidth" (optional.Int32) -  The maximum image width to return.
 * @param "MaxHeight" (optional.Int32) -  The maximum image height to return.
 * @param "PercentPlayed" (optional.Float64) -  Optional. Percent to render for the percent played overlay.
 * @param "UnplayedCount" (optional.Int32) -  Optional. Unplayed count overlay to render.
 * @param "Width" (optional.Int32) -  The fixed image width to return.
 * @param "Height" (optional.Int32) -  The fixed image height to return.
 * @param "Quality" (optional.Int32) -  Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
 * @param "CropWhitespace" (optional.Bool) -  Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
 * @param "AddPlayedIndicator" (optional.Bool) -  Optional. Add a played indicator.
 * @param "Blur" (optional.Int32) -  Optional. Blur image.
 * @param "BackgroundColor" (optional.String) -  Optional. Apply a background color for transparent images.
 * @param "ForegroundLayer" (optional.String) -  Optional. Apply a foreground layer on top of the image.
@return *os.File
*/
func (a *ImageApiService) HeadArtistImage(ctx _context.Context, name string, imageType ImageType, imageIndex int32, localVarOptionals *HeadArtistImageOpts) (*os.File, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodHead
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  *os.File
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Artists/{name}/Images/{imageType}/{imageIndex}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", _neturl.QueryEscape(parameterToString(name, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"imageType"+"}", _neturl.QueryEscape(parameterToString(imageType, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"imageIndex"+"}", _neturl.QueryEscape(parameterToString(imageIndex, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Tag.IsSet() {
		localVarQueryParams.Add("tag", parameterToString(localVarOptionals.Tag.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MaxWidth.IsSet() {
		localVarQueryParams.Add("maxWidth", parameterToString(localVarOptionals.MaxWidth.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MaxHeight.IsSet() {
		localVarQueryParams.Add("maxHeight", parameterToString(localVarOptionals.MaxHeight.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PercentPlayed.IsSet() {
		localVarQueryParams.Add("percentPlayed", parameterToString(localVarOptionals.PercentPlayed.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.UnplayedCount.IsSet() {
		localVarQueryParams.Add("unplayedCount", parameterToString(localVarOptionals.UnplayedCount.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Width.IsSet() {
		localVarQueryParams.Add("width", parameterToString(localVarOptionals.Width.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Height.IsSet() {
		localVarQueryParams.Add("height", parameterToString(localVarOptionals.Height.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Quality.IsSet() {
		localVarQueryParams.Add("quality", parameterToString(localVarOptionals.Quality.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CropWhitespace.IsSet() {
		localVarQueryParams.Add("cropWhitespace", parameterToString(localVarOptionals.CropWhitespace.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AddPlayedIndicator.IsSet() {
		localVarQueryParams.Add("addPlayedIndicator", parameterToString(localVarOptionals.AddPlayedIndicator.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Blur.IsSet() {
		localVarQueryParams.Add("blur", parameterToString(localVarOptionals.Blur.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.BackgroundColor.IsSet() {
		localVarQueryParams.Add("backgroundColor", parameterToString(localVarOptionals.BackgroundColor.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ForegroundLayer.IsSet() {
		localVarQueryParams.Add("foregroundLayer", parameterToString(localVarOptionals.ForegroundLayer.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"image/_*", "application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["X-Emby-Authorization"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// HeadGenreImageOpts Optional parameters for the method 'HeadGenreImage'
type HeadGenreImageOpts struct {
    Tag optional.String
    Format optional.Interface
    MaxWidth optional.Int32
    MaxHeight optional.Int32
    PercentPlayed optional.Float64
    UnplayedCount optional.Int32
    Width optional.Int32
    Height optional.Int32
    Quality optional.Int32
    CropWhitespace optional.Bool
    AddPlayedIndicator optional.Bool
    Blur optional.Int32
    BackgroundColor optional.String
    ForegroundLayer optional.String
}

/*
HeadGenreImage Get genre image by name.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param name Genre name.
 * @param imageType Image type.
 * @param imageIndex Image index.
 * @param optional nil or *HeadGenreImageOpts - Optional Parameters:
 * @param "Tag" (optional.String) -  Optional. Supply the cache tag from the item object to receive strong caching headers.
 * @param "Format" (optional.Interface of ImageFormat) -  Determines the output format of the image - original,gif,jpg,png.
 * @param "MaxWidth" (optional.Int32) -  The maximum image width to return.
 * @param "MaxHeight" (optional.Int32) -  The maximum image height to return.
 * @param "PercentPlayed" (optional.Float64) -  Optional. Percent to render for the percent played overlay.
 * @param "UnplayedCount" (optional.Int32) -  Optional. Unplayed count overlay to render.
 * @param "Width" (optional.Int32) -  The fixed image width to return.
 * @param "Height" (optional.Int32) -  The fixed image height to return.
 * @param "Quality" (optional.Int32) -  Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
 * @param "CropWhitespace" (optional.Bool) -  Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
 * @param "AddPlayedIndicator" (optional.Bool) -  Optional. Add a played indicator.
 * @param "Blur" (optional.Int32) -  Optional. Blur image.
 * @param "BackgroundColor" (optional.String) -  Optional. Apply a background color for transparent images.
 * @param "ForegroundLayer" (optional.String) -  Optional. Apply a foreground layer on top of the image.
@return *os.File
*/
func (a *ImageApiService) HeadGenreImage(ctx _context.Context, name string, imageType ImageType, imageIndex int32, localVarOptionals *HeadGenreImageOpts) (*os.File, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodHead
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  *os.File
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Genres/{name}/Images/{imageType}/{imageIndex}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", _neturl.QueryEscape(parameterToString(name, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"imageType"+"}", _neturl.QueryEscape(parameterToString(imageType, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"imageIndex"+"}", _neturl.QueryEscape(parameterToString(imageIndex, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Tag.IsSet() {
		localVarQueryParams.Add("tag", parameterToString(localVarOptionals.Tag.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MaxWidth.IsSet() {
		localVarQueryParams.Add("maxWidth", parameterToString(localVarOptionals.MaxWidth.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MaxHeight.IsSet() {
		localVarQueryParams.Add("maxHeight", parameterToString(localVarOptionals.MaxHeight.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PercentPlayed.IsSet() {
		localVarQueryParams.Add("percentPlayed", parameterToString(localVarOptionals.PercentPlayed.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.UnplayedCount.IsSet() {
		localVarQueryParams.Add("unplayedCount", parameterToString(localVarOptionals.UnplayedCount.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Width.IsSet() {
		localVarQueryParams.Add("width", parameterToString(localVarOptionals.Width.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Height.IsSet() {
		localVarQueryParams.Add("height", parameterToString(localVarOptionals.Height.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Quality.IsSet() {
		localVarQueryParams.Add("quality", parameterToString(localVarOptionals.Quality.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CropWhitespace.IsSet() {
		localVarQueryParams.Add("cropWhitespace", parameterToString(localVarOptionals.CropWhitespace.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AddPlayedIndicator.IsSet() {
		localVarQueryParams.Add("addPlayedIndicator", parameterToString(localVarOptionals.AddPlayedIndicator.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Blur.IsSet() {
		localVarQueryParams.Add("blur", parameterToString(localVarOptionals.Blur.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.BackgroundColor.IsSet() {
		localVarQueryParams.Add("backgroundColor", parameterToString(localVarOptionals.BackgroundColor.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ForegroundLayer.IsSet() {
		localVarQueryParams.Add("foregroundLayer", parameterToString(localVarOptionals.ForegroundLayer.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"image/_*", "application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["X-Emby-Authorization"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// HeadItemImageOpts Optional parameters for the method 'HeadItemImage'
type HeadItemImageOpts struct {
    MaxWidth optional.Int32
    MaxHeight optional.Int32
    Width optional.Int32
    Height optional.Int32
    Quality optional.Int32
    Tag optional.String
    CropWhitespace optional.Bool
    Format optional.Interface
    AddPlayedIndicator optional.Bool
    PercentPlayed optional.Float64
    UnplayedCount optional.Int32
    Blur optional.Int32
    BackgroundColor optional.String
    ForegroundLayer optional.String
}

/*
HeadItemImage Gets the item's image.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param itemId Item id.
 * @param imageType Image type.
 * @param imageIndex Image index.
 * @param optional nil or *HeadItemImageOpts - Optional Parameters:
 * @param "MaxWidth" (optional.Int32) -  The maximum image width to return.
 * @param "MaxHeight" (optional.Int32) -  The maximum image height to return.
 * @param "Width" (optional.Int32) -  The fixed image width to return.
 * @param "Height" (optional.Int32) -  The fixed image height to return.
 * @param "Quality" (optional.Int32) -  Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
 * @param "Tag" (optional.String) -  Optional. Supply the cache tag from the item object to receive strong caching headers.
 * @param "CropWhitespace" (optional.Bool) -  Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
 * @param "Format" (optional.Interface of ImageFormat) -  Optional. The MediaBrowser.Model.Drawing.ImageFormat of the returned image.
 * @param "AddPlayedIndicator" (optional.Bool) -  Optional. Add a played indicator.
 * @param "PercentPlayed" (optional.Float64) -  Optional. Percent to render for the percent played overlay.
 * @param "UnplayedCount" (optional.Int32) -  Optional. Unplayed count overlay to render.
 * @param "Blur" (optional.Int32) -  Optional. Blur image.
 * @param "BackgroundColor" (optional.String) -  Optional. Apply a background color for transparent images.
 * @param "ForegroundLayer" (optional.String) -  Optional. Apply a foreground layer on top of the image.
@return *os.File
*/
func (a *ImageApiService) HeadItemImage(ctx _context.Context, itemId string, imageType ImageType, imageIndex int32, localVarOptionals *HeadItemImageOpts) (*os.File, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodHead
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  *os.File
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Items/{itemId}/Images/{imageType}"
	localVarPath = strings.Replace(localVarPath, "{"+"itemId"+"}", _neturl.QueryEscape(parameterToString(itemId, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"imageType"+"}", _neturl.QueryEscape(parameterToString(imageType, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"imageIndex"+"}", _neturl.QueryEscape(parameterToString(imageIndex, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.MaxWidth.IsSet() {
		localVarQueryParams.Add("maxWidth", parameterToString(localVarOptionals.MaxWidth.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MaxHeight.IsSet() {
		localVarQueryParams.Add("maxHeight", parameterToString(localVarOptionals.MaxHeight.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Width.IsSet() {
		localVarQueryParams.Add("width", parameterToString(localVarOptionals.Width.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Height.IsSet() {
		localVarQueryParams.Add("height", parameterToString(localVarOptionals.Height.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Quality.IsSet() {
		localVarQueryParams.Add("quality", parameterToString(localVarOptionals.Quality.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Tag.IsSet() {
		localVarQueryParams.Add("tag", parameterToString(localVarOptionals.Tag.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CropWhitespace.IsSet() {
		localVarQueryParams.Add("cropWhitespace", parameterToString(localVarOptionals.CropWhitespace.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AddPlayedIndicator.IsSet() {
		localVarQueryParams.Add("addPlayedIndicator", parameterToString(localVarOptionals.AddPlayedIndicator.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PercentPlayed.IsSet() {
		localVarQueryParams.Add("percentPlayed", parameterToString(localVarOptionals.PercentPlayed.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.UnplayedCount.IsSet() {
		localVarQueryParams.Add("unplayedCount", parameterToString(localVarOptionals.UnplayedCount.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Blur.IsSet() {
		localVarQueryParams.Add("blur", parameterToString(localVarOptionals.Blur.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.BackgroundColor.IsSet() {
		localVarQueryParams.Add("backgroundColor", parameterToString(localVarOptionals.BackgroundColor.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ForegroundLayer.IsSet() {
		localVarQueryParams.Add("foregroundLayer", parameterToString(localVarOptionals.ForegroundLayer.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"image/_*", "application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["X-Emby-Authorization"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// HeadItemImage2Opts Optional parameters for the method 'HeadItemImage2'
type HeadItemImage2Opts struct {
    MaxWidth optional.Int32
    MaxHeight optional.Int32
    Width optional.Int32
    Height optional.Int32
    Quality optional.Int32
    Tag optional.String
    CropWhitespace optional.Bool
    Format optional.Interface
    AddPlayedIndicator optional.Bool
    PercentPlayed optional.Float64
    UnplayedCount optional.Int32
    Blur optional.Int32
    BackgroundColor optional.String
    ForegroundLayer optional.String
}

/*
HeadItemImage2 Gets the item's image.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param itemId Item id.
 * @param imageType Image type.
 * @param imageIndex Image index.
 * @param optional nil or *HeadItemImage2Opts - Optional Parameters:
 * @param "MaxWidth" (optional.Int32) -  The maximum image width to return.
 * @param "MaxHeight" (optional.Int32) -  The maximum image height to return.
 * @param "Width" (optional.Int32) -  The fixed image width to return.
 * @param "Height" (optional.Int32) -  The fixed image height to return.
 * @param "Quality" (optional.Int32) -  Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
 * @param "Tag" (optional.String) -  Optional. Supply the cache tag from the item object to receive strong caching headers.
 * @param "CropWhitespace" (optional.Bool) -  Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
 * @param "Format" (optional.Interface of ImageFormat) -  Optional. The MediaBrowser.Model.Drawing.ImageFormat of the returned image.
 * @param "AddPlayedIndicator" (optional.Bool) -  Optional. Add a played indicator.
 * @param "PercentPlayed" (optional.Float64) -  Optional. Percent to render for the percent played overlay.
 * @param "UnplayedCount" (optional.Int32) -  Optional. Unplayed count overlay to render.
 * @param "Blur" (optional.Int32) -  Optional. Blur image.
 * @param "BackgroundColor" (optional.String) -  Optional. Apply a background color for transparent images.
 * @param "ForegroundLayer" (optional.String) -  Optional. Apply a foreground layer on top of the image.
@return *os.File
*/
func (a *ImageApiService) HeadItemImage2(ctx _context.Context, itemId string, imageType ImageType, imageIndex int32, localVarOptionals *HeadItemImage2Opts) (*os.File, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodHead
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  *os.File
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Items/{itemId}/Images/{imageType}/{imageIndex}"
	localVarPath = strings.Replace(localVarPath, "{"+"itemId"+"}", _neturl.QueryEscape(parameterToString(itemId, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"imageType"+"}", _neturl.QueryEscape(parameterToString(imageType, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"imageIndex"+"}", _neturl.QueryEscape(parameterToString(imageIndex, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.MaxWidth.IsSet() {
		localVarQueryParams.Add("maxWidth", parameterToString(localVarOptionals.MaxWidth.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MaxHeight.IsSet() {
		localVarQueryParams.Add("maxHeight", parameterToString(localVarOptionals.MaxHeight.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Width.IsSet() {
		localVarQueryParams.Add("width", parameterToString(localVarOptionals.Width.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Height.IsSet() {
		localVarQueryParams.Add("height", parameterToString(localVarOptionals.Height.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Quality.IsSet() {
		localVarQueryParams.Add("quality", parameterToString(localVarOptionals.Quality.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Tag.IsSet() {
		localVarQueryParams.Add("tag", parameterToString(localVarOptionals.Tag.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CropWhitespace.IsSet() {
		localVarQueryParams.Add("cropWhitespace", parameterToString(localVarOptionals.CropWhitespace.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AddPlayedIndicator.IsSet() {
		localVarQueryParams.Add("addPlayedIndicator", parameterToString(localVarOptionals.AddPlayedIndicator.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PercentPlayed.IsSet() {
		localVarQueryParams.Add("percentPlayed", parameterToString(localVarOptionals.PercentPlayed.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.UnplayedCount.IsSet() {
		localVarQueryParams.Add("unplayedCount", parameterToString(localVarOptionals.UnplayedCount.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Blur.IsSet() {
		localVarQueryParams.Add("blur", parameterToString(localVarOptionals.Blur.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.BackgroundColor.IsSet() {
		localVarQueryParams.Add("backgroundColor", parameterToString(localVarOptionals.BackgroundColor.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ForegroundLayer.IsSet() {
		localVarQueryParams.Add("foregroundLayer", parameterToString(localVarOptionals.ForegroundLayer.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"image/_*", "application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["X-Emby-Authorization"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// HeadItemImage2_2Opts Optional parameters for the method 'HeadItemImage2_2'
type HeadItemImage2_2Opts struct {
    Width optional.Int32
    Height optional.Int32
    Quality optional.Int32
    CropWhitespace optional.Bool
    AddPlayedIndicator optional.Bool
    Blur optional.Int32
    BackgroundColor optional.String
    ForegroundLayer optional.String
}

/*
HeadItemImage2_0 Gets the item's image.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param itemId Item id.
 * @param imageType Image type.
 * @param maxWidth The maximum image width to return.
 * @param maxHeight The maximum image height to return.
 * @param tag Optional. Supply the cache tag from the item object to receive strong caching headers.
 * @param format Determines the output format of the image - original,gif,jpg,png.
 * @param percentPlayed Optional. Percent to render for the percent played overlay.
 * @param unplayedCount Optional. Unplayed count overlay to render.
 * @param imageIndex Image index.
 * @param optional nil or *HeadItemImage2_2Opts - Optional Parameters:
 * @param "Width" (optional.Int32) -  The fixed image width to return.
 * @param "Height" (optional.Int32) -  The fixed image height to return.
 * @param "Quality" (optional.Int32) -  Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
 * @param "CropWhitespace" (optional.Bool) -  Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
 * @param "AddPlayedIndicator" (optional.Bool) -  Optional. Add a played indicator.
 * @param "Blur" (optional.Int32) -  Optional. Blur image.
 * @param "BackgroundColor" (optional.String) -  Optional. Apply a background color for transparent images.
 * @param "ForegroundLayer" (optional.String) -  Optional. Apply a foreground layer on top of the image.
@return *os.File
*/
func (a *ImageApiService) HeadItemImage2_2(ctx _context.Context, itemId string, imageType ImageType, maxWidth int32, maxHeight int32, tag string, format ImageFormat, percentPlayed float64, unplayedCount int32, imageIndex int32, localVarOptionals *HeadItemImage2_2Opts) (*os.File, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodHead
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  *os.File
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Items/{itemId}/Images/{imageType}/{imageIndex}/{tag}/{format}/{maxWidth}/{maxHeight}/{percentPlayed}/{unplayedCount}"
	localVarPath = strings.Replace(localVarPath, "{"+"itemId"+"}", _neturl.QueryEscape(parameterToString(itemId, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"imageType"+"}", _neturl.QueryEscape(parameterToString(imageType, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"maxWidth"+"}", _neturl.QueryEscape(parameterToString(maxWidth, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"maxHeight"+"}", _neturl.QueryEscape(parameterToString(maxHeight, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"tag"+"}", _neturl.QueryEscape(parameterToString(tag, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"format"+"}", _neturl.QueryEscape(parameterToString(format, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"percentPlayed"+"}", _neturl.QueryEscape(parameterToString(percentPlayed, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"unplayedCount"+"}", _neturl.QueryEscape(parameterToString(unplayedCount, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"imageIndex"+"}", _neturl.QueryEscape(parameterToString(imageIndex, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Width.IsSet() {
		localVarQueryParams.Add("width", parameterToString(localVarOptionals.Width.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Height.IsSet() {
		localVarQueryParams.Add("height", parameterToString(localVarOptionals.Height.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Quality.IsSet() {
		localVarQueryParams.Add("quality", parameterToString(localVarOptionals.Quality.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CropWhitespace.IsSet() {
		localVarQueryParams.Add("cropWhitespace", parameterToString(localVarOptionals.CropWhitespace.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AddPlayedIndicator.IsSet() {
		localVarQueryParams.Add("addPlayedIndicator", parameterToString(localVarOptionals.AddPlayedIndicator.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Blur.IsSet() {
		localVarQueryParams.Add("blur", parameterToString(localVarOptionals.Blur.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.BackgroundColor.IsSet() {
		localVarQueryParams.Add("backgroundColor", parameterToString(localVarOptionals.BackgroundColor.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ForegroundLayer.IsSet() {
		localVarQueryParams.Add("foregroundLayer", parameterToString(localVarOptionals.ForegroundLayer.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"image/_*", "application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["X-Emby-Authorization"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// HeadMusicGenreImageOpts Optional parameters for the method 'HeadMusicGenreImage'
type HeadMusicGenreImageOpts struct {
    Tag optional.String
    Format optional.Interface
    MaxWidth optional.Int32
    MaxHeight optional.Int32
    PercentPlayed optional.Float64
    UnplayedCount optional.Int32
    Width optional.Int32
    Height optional.Int32
    Quality optional.Int32
    CropWhitespace optional.Bool
    AddPlayedIndicator optional.Bool
    Blur optional.Int32
    BackgroundColor optional.String
    ForegroundLayer optional.String
}

/*
HeadMusicGenreImage Get music genre image by name.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param name Music genre name.
 * @param imageType Image type.
 * @param imageIndex Image index.
 * @param optional nil or *HeadMusicGenreImageOpts - Optional Parameters:
 * @param "Tag" (optional.String) -  Optional. Supply the cache tag from the item object to receive strong caching headers.
 * @param "Format" (optional.Interface of ImageFormat) -  Determines the output format of the image - original,gif,jpg,png.
 * @param "MaxWidth" (optional.Int32) -  The maximum image width to return.
 * @param "MaxHeight" (optional.Int32) -  The maximum image height to return.
 * @param "PercentPlayed" (optional.Float64) -  Optional. Percent to render for the percent played overlay.
 * @param "UnplayedCount" (optional.Int32) -  Optional. Unplayed count overlay to render.
 * @param "Width" (optional.Int32) -  The fixed image width to return.
 * @param "Height" (optional.Int32) -  The fixed image height to return.
 * @param "Quality" (optional.Int32) -  Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
 * @param "CropWhitespace" (optional.Bool) -  Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
 * @param "AddPlayedIndicator" (optional.Bool) -  Optional. Add a played indicator.
 * @param "Blur" (optional.Int32) -  Optional. Blur image.
 * @param "BackgroundColor" (optional.String) -  Optional. Apply a background color for transparent images.
 * @param "ForegroundLayer" (optional.String) -  Optional. Apply a foreground layer on top of the image.
@return *os.File
*/
func (a *ImageApiService) HeadMusicGenreImage(ctx _context.Context, name string, imageType ImageType, imageIndex int32, localVarOptionals *HeadMusicGenreImageOpts) (*os.File, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodHead
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  *os.File
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/MusicGenres/{name}/Images/{imageType}/{imageIndex}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", _neturl.QueryEscape(parameterToString(name, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"imageType"+"}", _neturl.QueryEscape(parameterToString(imageType, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"imageIndex"+"}", _neturl.QueryEscape(parameterToString(imageIndex, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Tag.IsSet() {
		localVarQueryParams.Add("tag", parameterToString(localVarOptionals.Tag.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MaxWidth.IsSet() {
		localVarQueryParams.Add("maxWidth", parameterToString(localVarOptionals.MaxWidth.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MaxHeight.IsSet() {
		localVarQueryParams.Add("maxHeight", parameterToString(localVarOptionals.MaxHeight.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PercentPlayed.IsSet() {
		localVarQueryParams.Add("percentPlayed", parameterToString(localVarOptionals.PercentPlayed.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.UnplayedCount.IsSet() {
		localVarQueryParams.Add("unplayedCount", parameterToString(localVarOptionals.UnplayedCount.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Width.IsSet() {
		localVarQueryParams.Add("width", parameterToString(localVarOptionals.Width.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Height.IsSet() {
		localVarQueryParams.Add("height", parameterToString(localVarOptionals.Height.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Quality.IsSet() {
		localVarQueryParams.Add("quality", parameterToString(localVarOptionals.Quality.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CropWhitespace.IsSet() {
		localVarQueryParams.Add("cropWhitespace", parameterToString(localVarOptionals.CropWhitespace.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AddPlayedIndicator.IsSet() {
		localVarQueryParams.Add("addPlayedIndicator", parameterToString(localVarOptionals.AddPlayedIndicator.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Blur.IsSet() {
		localVarQueryParams.Add("blur", parameterToString(localVarOptionals.Blur.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.BackgroundColor.IsSet() {
		localVarQueryParams.Add("backgroundColor", parameterToString(localVarOptionals.BackgroundColor.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ForegroundLayer.IsSet() {
		localVarQueryParams.Add("foregroundLayer", parameterToString(localVarOptionals.ForegroundLayer.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"image/_*", "application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["X-Emby-Authorization"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// HeadPersonImageOpts Optional parameters for the method 'HeadPersonImage'
type HeadPersonImageOpts struct {
    Tag optional.String
    Format optional.Interface
    MaxWidth optional.Int32
    MaxHeight optional.Int32
    PercentPlayed optional.Float64
    UnplayedCount optional.Int32
    Width optional.Int32
    Height optional.Int32
    Quality optional.Int32
    CropWhitespace optional.Bool
    AddPlayedIndicator optional.Bool
    Blur optional.Int32
    BackgroundColor optional.String
    ForegroundLayer optional.String
}

/*
HeadPersonImage Get person image by name.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param name Person name.
 * @param imageType Image type.
 * @param imageIndex Image index.
 * @param optional nil or *HeadPersonImageOpts - Optional Parameters:
 * @param "Tag" (optional.String) -  Optional. Supply the cache tag from the item object to receive strong caching headers.
 * @param "Format" (optional.Interface of ImageFormat) -  Determines the output format of the image - original,gif,jpg,png.
 * @param "MaxWidth" (optional.Int32) -  The maximum image width to return.
 * @param "MaxHeight" (optional.Int32) -  The maximum image height to return.
 * @param "PercentPlayed" (optional.Float64) -  Optional. Percent to render for the percent played overlay.
 * @param "UnplayedCount" (optional.Int32) -  Optional. Unplayed count overlay to render.
 * @param "Width" (optional.Int32) -  The fixed image width to return.
 * @param "Height" (optional.Int32) -  The fixed image height to return.
 * @param "Quality" (optional.Int32) -  Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
 * @param "CropWhitespace" (optional.Bool) -  Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
 * @param "AddPlayedIndicator" (optional.Bool) -  Optional. Add a played indicator.
 * @param "Blur" (optional.Int32) -  Optional. Blur image.
 * @param "BackgroundColor" (optional.String) -  Optional. Apply a background color for transparent images.
 * @param "ForegroundLayer" (optional.String) -  Optional. Apply a foreground layer on top of the image.
@return *os.File
*/
func (a *ImageApiService) HeadPersonImage(ctx _context.Context, name string, imageType ImageType, imageIndex int32, localVarOptionals *HeadPersonImageOpts) (*os.File, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodHead
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  *os.File
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Persons/{name}/Images/{imageType}/{imageIndex}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", _neturl.QueryEscape(parameterToString(name, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"imageType"+"}", _neturl.QueryEscape(parameterToString(imageType, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"imageIndex"+"}", _neturl.QueryEscape(parameterToString(imageIndex, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Tag.IsSet() {
		localVarQueryParams.Add("tag", parameterToString(localVarOptionals.Tag.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MaxWidth.IsSet() {
		localVarQueryParams.Add("maxWidth", parameterToString(localVarOptionals.MaxWidth.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MaxHeight.IsSet() {
		localVarQueryParams.Add("maxHeight", parameterToString(localVarOptionals.MaxHeight.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PercentPlayed.IsSet() {
		localVarQueryParams.Add("percentPlayed", parameterToString(localVarOptionals.PercentPlayed.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.UnplayedCount.IsSet() {
		localVarQueryParams.Add("unplayedCount", parameterToString(localVarOptionals.UnplayedCount.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Width.IsSet() {
		localVarQueryParams.Add("width", parameterToString(localVarOptionals.Width.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Height.IsSet() {
		localVarQueryParams.Add("height", parameterToString(localVarOptionals.Height.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Quality.IsSet() {
		localVarQueryParams.Add("quality", parameterToString(localVarOptionals.Quality.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CropWhitespace.IsSet() {
		localVarQueryParams.Add("cropWhitespace", parameterToString(localVarOptionals.CropWhitespace.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AddPlayedIndicator.IsSet() {
		localVarQueryParams.Add("addPlayedIndicator", parameterToString(localVarOptionals.AddPlayedIndicator.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Blur.IsSet() {
		localVarQueryParams.Add("blur", parameterToString(localVarOptionals.Blur.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.BackgroundColor.IsSet() {
		localVarQueryParams.Add("backgroundColor", parameterToString(localVarOptionals.BackgroundColor.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ForegroundLayer.IsSet() {
		localVarQueryParams.Add("foregroundLayer", parameterToString(localVarOptionals.ForegroundLayer.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"image/_*", "application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["X-Emby-Authorization"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// HeadStudioImageOpts Optional parameters for the method 'HeadStudioImage'
type HeadStudioImageOpts struct {
    MaxWidth optional.Int32
    MaxHeight optional.Int32
    PercentPlayed optional.Float64
    UnplayedCount optional.Int32
    Width optional.Int32
    Height optional.Int32
    Quality optional.Int32
    CropWhitespace optional.Bool
    AddPlayedIndicator optional.Bool
    Blur optional.Int32
    BackgroundColor optional.String
    ForegroundLayer optional.String
}

/*
HeadStudioImage Get studio image by name.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param name Studio name.
 * @param imageType Image type.
 * @param tag Optional. Supply the cache tag from the item object to receive strong caching headers.
 * @param format Determines the output format of the image - original,gif,jpg,png.
 * @param imageIndex Image index.
 * @param optional nil or *HeadStudioImageOpts - Optional Parameters:
 * @param "MaxWidth" (optional.Int32) -  The maximum image width to return.
 * @param "MaxHeight" (optional.Int32) -  The maximum image height to return.
 * @param "PercentPlayed" (optional.Float64) -  Optional. Percent to render for the percent played overlay.
 * @param "UnplayedCount" (optional.Int32) -  Optional. Unplayed count overlay to render.
 * @param "Width" (optional.Int32) -  The fixed image width to return.
 * @param "Height" (optional.Int32) -  The fixed image height to return.
 * @param "Quality" (optional.Int32) -  Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
 * @param "CropWhitespace" (optional.Bool) -  Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
 * @param "AddPlayedIndicator" (optional.Bool) -  Optional. Add a played indicator.
 * @param "Blur" (optional.Int32) -  Optional. Blur image.
 * @param "BackgroundColor" (optional.String) -  Optional. Apply a background color for transparent images.
 * @param "ForegroundLayer" (optional.String) -  Optional. Apply a foreground layer on top of the image.
@return *os.File
*/
func (a *ImageApiService) HeadStudioImage(ctx _context.Context, name string, imageType ImageType, tag string, format ImageFormat, imageIndex int32, localVarOptionals *HeadStudioImageOpts) (*os.File, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodHead
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  *os.File
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Studios/{name}/Images/{imageType}/{imageIndex}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", _neturl.QueryEscape(parameterToString(name, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"imageType"+"}", _neturl.QueryEscape(parameterToString(imageType, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"tag"+"}", _neturl.QueryEscape(parameterToString(tag, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"format"+"}", _neturl.QueryEscape(parameterToString(format, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"imageIndex"+"}", _neturl.QueryEscape(parameterToString(imageIndex, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.MaxWidth.IsSet() {
		localVarQueryParams.Add("maxWidth", parameterToString(localVarOptionals.MaxWidth.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MaxHeight.IsSet() {
		localVarQueryParams.Add("maxHeight", parameterToString(localVarOptionals.MaxHeight.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PercentPlayed.IsSet() {
		localVarQueryParams.Add("percentPlayed", parameterToString(localVarOptionals.PercentPlayed.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.UnplayedCount.IsSet() {
		localVarQueryParams.Add("unplayedCount", parameterToString(localVarOptionals.UnplayedCount.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Width.IsSet() {
		localVarQueryParams.Add("width", parameterToString(localVarOptionals.Width.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Height.IsSet() {
		localVarQueryParams.Add("height", parameterToString(localVarOptionals.Height.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Quality.IsSet() {
		localVarQueryParams.Add("quality", parameterToString(localVarOptionals.Quality.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CropWhitespace.IsSet() {
		localVarQueryParams.Add("cropWhitespace", parameterToString(localVarOptionals.CropWhitespace.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AddPlayedIndicator.IsSet() {
		localVarQueryParams.Add("addPlayedIndicator", parameterToString(localVarOptionals.AddPlayedIndicator.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Blur.IsSet() {
		localVarQueryParams.Add("blur", parameterToString(localVarOptionals.Blur.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.BackgroundColor.IsSet() {
		localVarQueryParams.Add("backgroundColor", parameterToString(localVarOptionals.BackgroundColor.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ForegroundLayer.IsSet() {
		localVarQueryParams.Add("foregroundLayer", parameterToString(localVarOptionals.ForegroundLayer.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"image/_*", "application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["X-Emby-Authorization"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// HeadUserImageOpts Optional parameters for the method 'HeadUserImage'
type HeadUserImageOpts struct {
    Tag optional.String
    Format optional.Interface
    MaxWidth optional.Int32
    MaxHeight optional.Int32
    PercentPlayed optional.Float64
    UnplayedCount optional.Int32
    Width optional.Int32
    Height optional.Int32
    Quality optional.Int32
    CropWhitespace optional.Bool
    AddPlayedIndicator optional.Bool
    Blur optional.Int32
    BackgroundColor optional.String
    ForegroundLayer optional.String
}

/*
HeadUserImage Get user profile image.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param userId User id.
 * @param imageType Image type.
 * @param imageIndex Image index.
 * @param optional nil or *HeadUserImageOpts - Optional Parameters:
 * @param "Tag" (optional.String) -  Optional. Supply the cache tag from the item object to receive strong caching headers.
 * @param "Format" (optional.Interface of ImageFormat) -  Determines the output format of the image - original,gif,jpg,png.
 * @param "MaxWidth" (optional.Int32) -  The maximum image width to return.
 * @param "MaxHeight" (optional.Int32) -  The maximum image height to return.
 * @param "PercentPlayed" (optional.Float64) -  Optional. Percent to render for the percent played overlay.
 * @param "UnplayedCount" (optional.Int32) -  Optional. Unplayed count overlay to render.
 * @param "Width" (optional.Int32) -  The fixed image width to return.
 * @param "Height" (optional.Int32) -  The fixed image height to return.
 * @param "Quality" (optional.Int32) -  Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
 * @param "CropWhitespace" (optional.Bool) -  Optional. Specify if whitespace should be cropped out of the image. True/False. If unspecified, whitespace will be cropped from logos and clear art.
 * @param "AddPlayedIndicator" (optional.Bool) -  Optional. Add a played indicator.
 * @param "Blur" (optional.Int32) -  Optional. Blur image.
 * @param "BackgroundColor" (optional.String) -  Optional. Apply a background color for transparent images.
 * @param "ForegroundLayer" (optional.String) -  Optional. Apply a foreground layer on top of the image.
@return *os.File
*/
func (a *ImageApiService) HeadUserImage(ctx _context.Context, userId string, imageType ImageType, imageIndex int32, localVarOptionals *HeadUserImageOpts) (*os.File, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodHead
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  *os.File
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Users/{userId}/Images/{imageType}/{imageIndex}"
	localVarPath = strings.Replace(localVarPath, "{"+"userId"+"}", _neturl.QueryEscape(parameterToString(userId, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"imageType"+"}", _neturl.QueryEscape(parameterToString(imageType, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"imageIndex"+"}", _neturl.QueryEscape(parameterToString(imageIndex, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.Tag.IsSet() {
		localVarQueryParams.Add("tag", parameterToString(localVarOptionals.Tag.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Format.IsSet() {
		localVarQueryParams.Add("format", parameterToString(localVarOptionals.Format.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MaxWidth.IsSet() {
		localVarQueryParams.Add("maxWidth", parameterToString(localVarOptionals.MaxWidth.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MaxHeight.IsSet() {
		localVarQueryParams.Add("maxHeight", parameterToString(localVarOptionals.MaxHeight.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PercentPlayed.IsSet() {
		localVarQueryParams.Add("percentPlayed", parameterToString(localVarOptionals.PercentPlayed.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.UnplayedCount.IsSet() {
		localVarQueryParams.Add("unplayedCount", parameterToString(localVarOptionals.UnplayedCount.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Width.IsSet() {
		localVarQueryParams.Add("width", parameterToString(localVarOptionals.Width.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Height.IsSet() {
		localVarQueryParams.Add("height", parameterToString(localVarOptionals.Height.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Quality.IsSet() {
		localVarQueryParams.Add("quality", parameterToString(localVarOptionals.Quality.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CropWhitespace.IsSet() {
		localVarQueryParams.Add("cropWhitespace", parameterToString(localVarOptionals.CropWhitespace.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AddPlayedIndicator.IsSet() {
		localVarQueryParams.Add("addPlayedIndicator", parameterToString(localVarOptionals.AddPlayedIndicator.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Blur.IsSet() {
		localVarQueryParams.Add("blur", parameterToString(localVarOptionals.Blur.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.BackgroundColor.IsSet() {
		localVarQueryParams.Add("backgroundColor", parameterToString(localVarOptionals.BackgroundColor.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ForegroundLayer.IsSet() {
		localVarQueryParams.Add("foregroundLayer", parameterToString(localVarOptionals.ForegroundLayer.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"image/_*", "application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["X-Emby-Authorization"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
PostUserImage Sets the user image.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param userId User Id.
 * @param imageType (Unused) Image type.
 * @param index (Unused) Image index.
*/
func (a *ImageApiService) PostUserImage(ctx _context.Context, userId string, imageType ImageType, index int32) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Users/{userId}/Images/{imageType}"
	localVarPath = strings.Replace(localVarPath, "{"+"userId"+"}", _neturl.QueryEscape(parameterToString(userId, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"imageType"+"}", _neturl.QueryEscape(parameterToString(imageType, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", _neturl.QueryEscape(parameterToString(index, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["X-Emby-Authorization"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

/*
PostUserImage2 Sets the user image.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param userId User Id.
 * @param imageType (Unused) Image type.
 * @param index (Unused) Image index.
*/
func (a *ImageApiService) PostUserImage2(ctx _context.Context, userId string, imageType ImageType, index int32) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Users/{userId}/Images/{imageType}/{index}"
	localVarPath = strings.Replace(localVarPath, "{"+"userId"+"}", _neturl.QueryEscape(parameterToString(userId, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"imageType"+"}", _neturl.QueryEscape(parameterToString(imageType, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"index"+"}", _neturl.QueryEscape(parameterToString(index, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["X-Emby-Authorization"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

/*
SetItemImage Set item image.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param itemId Item id.
 * @param imageType Image type.
 * @param imageIndex (Unused) Image index.
*/
func (a *ImageApiService) SetItemImage(ctx _context.Context, itemId string, imageType ImageType, imageIndex int32) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Items/{itemId}/Images/{imageType}"
	localVarPath = strings.Replace(localVarPath, "{"+"itemId"+"}", _neturl.QueryEscape(parameterToString(itemId, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"imageType"+"}", _neturl.QueryEscape(parameterToString(imageType, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"imageIndex"+"}", _neturl.QueryEscape(parameterToString(imageIndex, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["X-Emby-Authorization"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

/*
SetItemImage2 Set item image.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param itemId Item id.
 * @param imageType Image type.
 * @param imageIndex (Unused) Image index.
*/
func (a *ImageApiService) SetItemImage2(ctx _context.Context, itemId string, imageType ImageType, imageIndex int32) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Items/{itemId}/Images/{imageType}/{imageIndex}"
	localVarPath = strings.Replace(localVarPath, "{"+"itemId"+"}", _neturl.QueryEscape(parameterToString(itemId, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"imageType"+"}", _neturl.QueryEscape(parameterToString(imageType, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"imageIndex"+"}", _neturl.QueryEscape(parameterToString(imageIndex, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["X-Emby-Authorization"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

// UpdateItemImageIndexOpts Optional parameters for the method 'UpdateItemImageIndex'
type UpdateItemImageIndexOpts struct {
    NewIndex optional.Int32
}

/*
UpdateItemImageIndex Updates the index for an item image.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param itemId Item id.
 * @param imageType Image type.
 * @param imageIndex Old image index.
 * @param optional nil or *UpdateItemImageIndexOpts - Optional Parameters:
 * @param "NewIndex" (optional.Int32) -  New image index.
*/
func (a *ImageApiService) UpdateItemImageIndex(ctx _context.Context, itemId string, imageType ImageType, imageIndex int32, localVarOptionals *UpdateItemImageIndexOpts) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Items/{itemId}/Images/{imageType}/{imageIndex}/Index"
	localVarPath = strings.Replace(localVarPath, "{"+"itemId"+"}", _neturl.QueryEscape(parameterToString(itemId, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"imageType"+"}", _neturl.QueryEscape(parameterToString(imageType, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"imageIndex"+"}", _neturl.QueryEscape(parameterToString(imageIndex, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.NewIndex.IsSet() {
		localVarQueryParams.Add("newIndex", parameterToString(localVarOptionals.NewIndex.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["X-Emby-Authorization"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
