/*
 * Jellyfin API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * API version: v1
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package client

import (
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
	"github.com/antihax/optional"
)

// Linger please
var (
	_ _context.Context
)

// TvShowsApiService TvShowsApi service
type TvShowsApiService service

// GetEpisodesOpts Optional parameters for the method 'GetEpisodes'
type GetEpisodesOpts struct {
    UserId optional.Interface
    Fields optional.String
    Season optional.Int32
    SeasonId optional.String
    IsMissing optional.Bool
    AdjacentTo optional.String
    StartItemId optional.String
    StartIndex optional.Int32
    Limit optional.Int32
    EnableImages optional.Bool
    ImageTypeLimit optional.Int32
    EnableImageTypes optional.String
    EnableUserData optional.Bool
    SortBy optional.String
}

/*
GetEpisodes Gets episodes for a tv season.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param seriesId The series id.
 * @param optional nil or *GetEpisodesOpts - Optional Parameters:
 * @param "UserId" (optional.Interface of string) -  The user id.
 * @param "Fields" (optional.String) -  Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
 * @param "Season" (optional.Int32) -  Optional filter by season number.
 * @param "SeasonId" (optional.String) -  Optional. Filter by season id.
 * @param "IsMissing" (optional.Bool) -  Optional. Filter by items that are missing episodes or not.
 * @param "AdjacentTo" (optional.String) -  Optional. Return items that are siblings of a supplied item.
 * @param "StartItemId" (optional.String) -  Optional. Skip through the list until a given item is found.
 * @param "StartIndex" (optional.Int32) -  Optional. The record index to start at. All items with a lower index will be dropped from the results.
 * @param "Limit" (optional.Int32) -  Optional. The maximum number of records to return.
 * @param "EnableImages" (optional.Bool) -  Optional, include image information in output.
 * @param "ImageTypeLimit" (optional.Int32) -  Optional, the max number of images to return, per image type.
 * @param "EnableImageTypes" (optional.String) -  Optional. The image types to include in the output.
 * @param "EnableUserData" (optional.Bool) -  Optional. Include user data.
 * @param "SortBy" (optional.String) -  Optional. Specify one or more sort orders, comma delimeted. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime.
@return BaseItemDtoQueryResult
*/
func (a *TvShowsApiService) GetEpisodes(ctx _context.Context, seriesId string, localVarOptionals *GetEpisodesOpts) (BaseItemDtoQueryResult, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  BaseItemDtoQueryResult
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Shows/{seriesId}/Episodes"
	localVarPath = strings.Replace(localVarPath, "{"+"seriesId"+"}", _neturl.QueryEscape(parameterToString(seriesId, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.UserId.IsSet() {
		localVarQueryParams.Add("userId", parameterToString(localVarOptionals.UserId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Season.IsSet() {
		localVarQueryParams.Add("season", parameterToString(localVarOptionals.Season.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SeasonId.IsSet() {
		localVarQueryParams.Add("seasonId", parameterToString(localVarOptionals.SeasonId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IsMissing.IsSet() {
		localVarQueryParams.Add("isMissing", parameterToString(localVarOptionals.IsMissing.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AdjacentTo.IsSet() {
		localVarQueryParams.Add("adjacentTo", parameterToString(localVarOptionals.AdjacentTo.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.StartItemId.IsSet() {
		localVarQueryParams.Add("startItemId", parameterToString(localVarOptionals.StartItemId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.StartIndex.IsSet() {
		localVarQueryParams.Add("startIndex", parameterToString(localVarOptionals.StartIndex.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EnableImages.IsSet() {
		localVarQueryParams.Add("enableImages", parameterToString(localVarOptionals.EnableImages.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ImageTypeLimit.IsSet() {
		localVarQueryParams.Add("imageTypeLimit", parameterToString(localVarOptionals.ImageTypeLimit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EnableImageTypes.IsSet() {
		localVarQueryParams.Add("enableImageTypes", parameterToString(localVarOptionals.EnableImageTypes.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EnableUserData.IsSet() {
		localVarQueryParams.Add("enableUserData", parameterToString(localVarOptionals.EnableUserData.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SortBy.IsSet() {
		localVarQueryParams.Add("sortBy", parameterToString(localVarOptionals.SortBy.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["X-Emby-Authorization"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// GetNextUpOpts Optional parameters for the method 'GetNextUp'
type GetNextUpOpts struct {
    UserId optional.Interface
    StartIndex optional.Int32
    Limit optional.Int32
    Fields optional.String
    SeriesId optional.String
    ParentId optional.String
    EnableImges optional.Bool
    ImageTypeLimit optional.Int32
    EnableImageTypes optional.String
    EnableUserData optional.Bool
    EnableTotalRecordCount optional.Bool
}

/*
GetNextUp Gets a list of next up episodes.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *GetNextUpOpts - Optional Parameters:
 * @param "UserId" (optional.Interface of string) -  The user id of the user to get the next up episodes for.
 * @param "StartIndex" (optional.Int32) -  Optional. The record index to start at. All items with a lower index will be dropped from the results.
 * @param "Limit" (optional.Int32) -  Optional. The maximum number of records to return.
 * @param "Fields" (optional.String) -  Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
 * @param "SeriesId" (optional.String) -  Optional. Filter by series id.
 * @param "ParentId" (optional.String) -  Optional. Specify this to localize the search to a specific item or folder. Omit to use the root.
 * @param "EnableImges" (optional.Bool) -  Optional. Include image information in output.
 * @param "ImageTypeLimit" (optional.Int32) -  Optional. The max number of images to return, per image type.
 * @param "EnableImageTypes" (optional.String) -  Optional. The image types to include in the output.
 * @param "EnableUserData" (optional.Bool) -  Optional. Include user data.
 * @param "EnableTotalRecordCount" (optional.Bool) -  Whether to enable the total records count. Defaults to true.
@return BaseItemDtoQueryResult
*/
func (a *TvShowsApiService) GetNextUp(ctx _context.Context, localVarOptionals *GetNextUpOpts) (BaseItemDtoQueryResult, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  BaseItemDtoQueryResult
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Shows/NextUp"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.UserId.IsSet() {
		localVarQueryParams.Add("userId", parameterToString(localVarOptionals.UserId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.StartIndex.IsSet() {
		localVarQueryParams.Add("startIndex", parameterToString(localVarOptionals.StartIndex.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SeriesId.IsSet() {
		localVarQueryParams.Add("seriesId", parameterToString(localVarOptionals.SeriesId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ParentId.IsSet() {
		localVarQueryParams.Add("parentId", parameterToString(localVarOptionals.ParentId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EnableImges.IsSet() {
		localVarQueryParams.Add("enableImges", parameterToString(localVarOptionals.EnableImges.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ImageTypeLimit.IsSet() {
		localVarQueryParams.Add("imageTypeLimit", parameterToString(localVarOptionals.ImageTypeLimit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EnableImageTypes.IsSet() {
		localVarQueryParams.Add("enableImageTypes", parameterToString(localVarOptionals.EnableImageTypes.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EnableUserData.IsSet() {
		localVarQueryParams.Add("enableUserData", parameterToString(localVarOptionals.EnableUserData.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EnableTotalRecordCount.IsSet() {
		localVarQueryParams.Add("enableTotalRecordCount", parameterToString(localVarOptionals.EnableTotalRecordCount.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["X-Emby-Authorization"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// GetSeasonsOpts Optional parameters for the method 'GetSeasons'
type GetSeasonsOpts struct {
    UserId optional.Interface
    Fields optional.String
    IsSpecialSeason optional.Bool
    IsMissing optional.Bool
    AdjacentTo optional.String
    EnableImages optional.Bool
    ImageTypeLimit optional.Int32
    EnableImageTypes optional.String
    EnableUserData optional.Bool
}

/*
GetSeasons Gets seasons for a tv series.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param seriesId The series id.
 * @param optional nil or *GetSeasonsOpts - Optional Parameters:
 * @param "UserId" (optional.Interface of string) -  The user id.
 * @param "Fields" (optional.String) -  Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
 * @param "IsSpecialSeason" (optional.Bool) -  Optional. Filter by special season.
 * @param "IsMissing" (optional.Bool) -  Optional. Filter by items that are missing episodes or not.
 * @param "AdjacentTo" (optional.String) -  Optional. Return items that are siblings of a supplied item.
 * @param "EnableImages" (optional.Bool) -  Optional. Include image information in output.
 * @param "ImageTypeLimit" (optional.Int32) -  Optional. The max number of images to return, per image type.
 * @param "EnableImageTypes" (optional.String) -  Optional. The image types to include in the output.
 * @param "EnableUserData" (optional.Bool) -  Optional. Include user data.
@return BaseItemDtoQueryResult
*/
func (a *TvShowsApiService) GetSeasons(ctx _context.Context, seriesId string, localVarOptionals *GetSeasonsOpts) (BaseItemDtoQueryResult, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  BaseItemDtoQueryResult
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Shows/{seriesId}/Seasons"
	localVarPath = strings.Replace(localVarPath, "{"+"seriesId"+"}", _neturl.QueryEscape(parameterToString(seriesId, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.UserId.IsSet() {
		localVarQueryParams.Add("userId", parameterToString(localVarOptionals.UserId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IsSpecialSeason.IsSet() {
		localVarQueryParams.Add("isSpecialSeason", parameterToString(localVarOptionals.IsSpecialSeason.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IsMissing.IsSet() {
		localVarQueryParams.Add("isMissing", parameterToString(localVarOptionals.IsMissing.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AdjacentTo.IsSet() {
		localVarQueryParams.Add("adjacentTo", parameterToString(localVarOptionals.AdjacentTo.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EnableImages.IsSet() {
		localVarQueryParams.Add("enableImages", parameterToString(localVarOptionals.EnableImages.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ImageTypeLimit.IsSet() {
		localVarQueryParams.Add("imageTypeLimit", parameterToString(localVarOptionals.ImageTypeLimit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EnableImageTypes.IsSet() {
		localVarQueryParams.Add("enableImageTypes", parameterToString(localVarOptionals.EnableImageTypes.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EnableUserData.IsSet() {
		localVarQueryParams.Add("enableUserData", parameterToString(localVarOptionals.EnableUserData.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["X-Emby-Authorization"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// GetUpcomingEpisodesOpts Optional parameters for the method 'GetUpcomingEpisodes'
type GetUpcomingEpisodesOpts struct {
    UserId optional.Interface
    StartIndex optional.Int32
    Limit optional.Int32
    Fields optional.String
    ParentId optional.String
    EnableImges optional.Bool
    ImageTypeLimit optional.Int32
    EnableImageTypes optional.String
    EnableUserData optional.Bool
}

/*
GetUpcomingEpisodes Gets a list of upcoming episodes.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *GetUpcomingEpisodesOpts - Optional Parameters:
 * @param "UserId" (optional.Interface of string) -  The user id of the user to get the upcoming episodes for.
 * @param "StartIndex" (optional.Int32) -  Optional. The record index to start at. All items with a lower index will be dropped from the results.
 * @param "Limit" (optional.Int32) -  Optional. The maximum number of records to return.
 * @param "Fields" (optional.String) -  Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimeted. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines, TrailerUrls.
 * @param "ParentId" (optional.String) -  Optional. Specify this to localize the search to a specific item or folder. Omit to use the root.
 * @param "EnableImges" (optional.Bool) -  Optional. Include image information in output.
 * @param "ImageTypeLimit" (optional.Int32) -  Optional. The max number of images to return, per image type.
 * @param "EnableImageTypes" (optional.String) -  Optional. The image types to include in the output.
 * @param "EnableUserData" (optional.Bool) -  Optional. Include user data.
@return BaseItemDtoQueryResult
*/
func (a *TvShowsApiService) GetUpcomingEpisodes(ctx _context.Context, localVarOptionals *GetUpcomingEpisodesOpts) (BaseItemDtoQueryResult, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  BaseItemDtoQueryResult
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Shows/Upcoming"
	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.UserId.IsSet() {
		localVarQueryParams.Add("userId", parameterToString(localVarOptionals.UserId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.StartIndex.IsSet() {
		localVarQueryParams.Add("startIndex", parameterToString(localVarOptionals.StartIndex.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Limit.IsSet() {
		localVarQueryParams.Add("limit", parameterToString(localVarOptionals.Limit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Fields.IsSet() {
		localVarQueryParams.Add("fields", parameterToString(localVarOptionals.Fields.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ParentId.IsSet() {
		localVarQueryParams.Add("parentId", parameterToString(localVarOptionals.ParentId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EnableImges.IsSet() {
		localVarQueryParams.Add("enableImges", parameterToString(localVarOptionals.EnableImges.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ImageTypeLimit.IsSet() {
		localVarQueryParams.Add("imageTypeLimit", parameterToString(localVarOptionals.ImageTypeLimit.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EnableImageTypes.IsSet() {
		localVarQueryParams.Add("enableImageTypes", parameterToString(localVarOptionals.EnableImageTypes.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EnableUserData.IsSet() {
		localVarQueryParams.Add("enableUserData", parameterToString(localVarOptionals.EnableUserData.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["X-Emby-Authorization"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
