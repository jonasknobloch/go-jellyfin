/*
 * Jellyfin API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * API version: v1
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package client

import (
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
	"os"
	"github.com/antihax/optional"
)

// Linger please
var (
	_ _context.Context
)

// UniversalAudioApiService UniversalAudioApi service
type UniversalAudioApiService service

// GetUniversalAudioStreamOpts Optional parameters for the method 'GetUniversalAudioStream'
type GetUniversalAudioStreamOpts struct {
    MediaSourceId optional.String
    DeviceId optional.String
    UserId optional.Interface
    AudioCodec optional.String
    MaxAudioChannels optional.Int32
    TranscodingAudioChannels optional.Int32
    MaxStreamingBitrate optional.Int64
    StartTimeTicks optional.Int64
    TranscodingContainer optional.String
    TranscodingProtocol optional.String
    MaxAudioSampleRate optional.Int32
    MaxAudioBitDepth optional.Int32
    EnableRemoteMedia optional.Bool
    BreakOnNonKeyFrames optional.Bool
    EnableRedirection optional.Bool
}

/*
GetUniversalAudioStream Gets an audio stream.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param itemId The item id.
 * @param container Optional. The audio container.
 * @param optional nil or *GetUniversalAudioStreamOpts - Optional Parameters:
 * @param "MediaSourceId" (optional.String) -  The media version id, if playing an alternate version.
 * @param "DeviceId" (optional.String) -  The device id of the client requesting. Used to stop encoding processes when needed.
 * @param "UserId" (optional.Interface of string) -  Optional. The user id.
 * @param "AudioCodec" (optional.String) -  Optional. The audio codec to transcode to.
 * @param "MaxAudioChannels" (optional.Int32) -  Optional. The maximum number of audio channels.
 * @param "TranscodingAudioChannels" (optional.Int32) -  Optional. The number of how many audio channels to transcode to.
 * @param "MaxStreamingBitrate" (optional.Int64) -  Optional. The maximum streaming bitrate.
 * @param "StartTimeTicks" (optional.Int64) -  Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms.
 * @param "TranscodingContainer" (optional.String) -  Optional. The container to transcode to.
 * @param "TranscodingProtocol" (optional.String) -  Optional. The transcoding protocol.
 * @param "MaxAudioSampleRate" (optional.Int32) -  Optional. The maximum audio sample rate.
 * @param "MaxAudioBitDepth" (optional.Int32) -  Optional. The maximum audio bit depth.
 * @param "EnableRemoteMedia" (optional.Bool) -  Optional. Whether to enable remote media.
 * @param "BreakOnNonKeyFrames" (optional.Bool) -  Optional. Whether to break on non key frames.
 * @param "EnableRedirection" (optional.Bool) -  Whether to enable redirection. Defaults to true.
@return *os.File
*/
func (a *UniversalAudioApiService) GetUniversalAudioStream(ctx _context.Context, itemId string, container string, localVarOptionals *GetUniversalAudioStreamOpts) (*os.File, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  *os.File
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Audio/{itemId}/universal"
	localVarPath = strings.Replace(localVarPath, "{"+"itemId"+"}", _neturl.QueryEscape(parameterToString(itemId, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"container"+"}", _neturl.QueryEscape(parameterToString(container, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.MediaSourceId.IsSet() {
		localVarQueryParams.Add("mediaSourceId", parameterToString(localVarOptionals.MediaSourceId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DeviceId.IsSet() {
		localVarQueryParams.Add("deviceId", parameterToString(localVarOptionals.DeviceId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.UserId.IsSet() {
		localVarQueryParams.Add("userId", parameterToString(localVarOptionals.UserId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AudioCodec.IsSet() {
		localVarQueryParams.Add("audioCodec", parameterToString(localVarOptionals.AudioCodec.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MaxAudioChannels.IsSet() {
		localVarQueryParams.Add("maxAudioChannels", parameterToString(localVarOptionals.MaxAudioChannels.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TranscodingAudioChannels.IsSet() {
		localVarQueryParams.Add("transcodingAudioChannels", parameterToString(localVarOptionals.TranscodingAudioChannels.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MaxStreamingBitrate.IsSet() {
		localVarQueryParams.Add("maxStreamingBitrate", parameterToString(localVarOptionals.MaxStreamingBitrate.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.StartTimeTicks.IsSet() {
		localVarQueryParams.Add("startTimeTicks", parameterToString(localVarOptionals.StartTimeTicks.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TranscodingContainer.IsSet() {
		localVarQueryParams.Add("transcodingContainer", parameterToString(localVarOptionals.TranscodingContainer.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TranscodingProtocol.IsSet() {
		localVarQueryParams.Add("transcodingProtocol", parameterToString(localVarOptionals.TranscodingProtocol.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MaxAudioSampleRate.IsSet() {
		localVarQueryParams.Add("maxAudioSampleRate", parameterToString(localVarOptionals.MaxAudioSampleRate.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MaxAudioBitDepth.IsSet() {
		localVarQueryParams.Add("maxAudioBitDepth", parameterToString(localVarOptionals.MaxAudioBitDepth.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EnableRemoteMedia.IsSet() {
		localVarQueryParams.Add("enableRemoteMedia", parameterToString(localVarOptionals.EnableRemoteMedia.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.BreakOnNonKeyFrames.IsSet() {
		localVarQueryParams.Add("breakOnNonKeyFrames", parameterToString(localVarOptionals.BreakOnNonKeyFrames.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EnableRedirection.IsSet() {
		localVarQueryParams.Add("enableRedirection", parameterToString(localVarOptionals.EnableRedirection.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"audio/_*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["X-Emby-Authorization"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// GetUniversalAudioStream2Opts Optional parameters for the method 'GetUniversalAudioStream2'
type GetUniversalAudioStream2Opts struct {
    MediaSourceId optional.String
    DeviceId optional.String
    UserId optional.Interface
    AudioCodec optional.String
    MaxAudioChannels optional.Int32
    TranscodingAudioChannels optional.Int32
    MaxStreamingBitrate optional.Int64
    StartTimeTicks optional.Int64
    TranscodingContainer optional.String
    TranscodingProtocol optional.String
    MaxAudioSampleRate optional.Int32
    MaxAudioBitDepth optional.Int32
    EnableRemoteMedia optional.Bool
    BreakOnNonKeyFrames optional.Bool
    EnableRedirection optional.Bool
}

/*
GetUniversalAudioStream2 Gets an audio stream.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param itemId The item id.
 * @param container Optional. The audio container.
 * @param optional nil or *GetUniversalAudioStream2Opts - Optional Parameters:
 * @param "MediaSourceId" (optional.String) -  The media version id, if playing an alternate version.
 * @param "DeviceId" (optional.String) -  The device id of the client requesting. Used to stop encoding processes when needed.
 * @param "UserId" (optional.Interface of string) -  Optional. The user id.
 * @param "AudioCodec" (optional.String) -  Optional. The audio codec to transcode to.
 * @param "MaxAudioChannels" (optional.Int32) -  Optional. The maximum number of audio channels.
 * @param "TranscodingAudioChannels" (optional.Int32) -  Optional. The number of how many audio channels to transcode to.
 * @param "MaxStreamingBitrate" (optional.Int64) -  Optional. The maximum streaming bitrate.
 * @param "StartTimeTicks" (optional.Int64) -  Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms.
 * @param "TranscodingContainer" (optional.String) -  Optional. The container to transcode to.
 * @param "TranscodingProtocol" (optional.String) -  Optional. The transcoding protocol.
 * @param "MaxAudioSampleRate" (optional.Int32) -  Optional. The maximum audio sample rate.
 * @param "MaxAudioBitDepth" (optional.Int32) -  Optional. The maximum audio bit depth.
 * @param "EnableRemoteMedia" (optional.Bool) -  Optional. Whether to enable remote media.
 * @param "BreakOnNonKeyFrames" (optional.Bool) -  Optional. Whether to break on non key frames.
 * @param "EnableRedirection" (optional.Bool) -  Whether to enable redirection. Defaults to true.
@return *os.File
*/
func (a *UniversalAudioApiService) GetUniversalAudioStream2(ctx _context.Context, itemId string, container string, localVarOptionals *GetUniversalAudioStream2Opts) (*os.File, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  *os.File
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Audio/{itemId}/universal.{container}"
	localVarPath = strings.Replace(localVarPath, "{"+"itemId"+"}", _neturl.QueryEscape(parameterToString(itemId, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"container"+"}", _neturl.QueryEscape(parameterToString(container, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.MediaSourceId.IsSet() {
		localVarQueryParams.Add("mediaSourceId", parameterToString(localVarOptionals.MediaSourceId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DeviceId.IsSet() {
		localVarQueryParams.Add("deviceId", parameterToString(localVarOptionals.DeviceId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.UserId.IsSet() {
		localVarQueryParams.Add("userId", parameterToString(localVarOptionals.UserId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AudioCodec.IsSet() {
		localVarQueryParams.Add("audioCodec", parameterToString(localVarOptionals.AudioCodec.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MaxAudioChannels.IsSet() {
		localVarQueryParams.Add("maxAudioChannels", parameterToString(localVarOptionals.MaxAudioChannels.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TranscodingAudioChannels.IsSet() {
		localVarQueryParams.Add("transcodingAudioChannels", parameterToString(localVarOptionals.TranscodingAudioChannels.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MaxStreamingBitrate.IsSet() {
		localVarQueryParams.Add("maxStreamingBitrate", parameterToString(localVarOptionals.MaxStreamingBitrate.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.StartTimeTicks.IsSet() {
		localVarQueryParams.Add("startTimeTicks", parameterToString(localVarOptionals.StartTimeTicks.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TranscodingContainer.IsSet() {
		localVarQueryParams.Add("transcodingContainer", parameterToString(localVarOptionals.TranscodingContainer.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TranscodingProtocol.IsSet() {
		localVarQueryParams.Add("transcodingProtocol", parameterToString(localVarOptionals.TranscodingProtocol.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MaxAudioSampleRate.IsSet() {
		localVarQueryParams.Add("maxAudioSampleRate", parameterToString(localVarOptionals.MaxAudioSampleRate.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MaxAudioBitDepth.IsSet() {
		localVarQueryParams.Add("maxAudioBitDepth", parameterToString(localVarOptionals.MaxAudioBitDepth.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EnableRemoteMedia.IsSet() {
		localVarQueryParams.Add("enableRemoteMedia", parameterToString(localVarOptionals.EnableRemoteMedia.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.BreakOnNonKeyFrames.IsSet() {
		localVarQueryParams.Add("breakOnNonKeyFrames", parameterToString(localVarOptionals.BreakOnNonKeyFrames.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EnableRedirection.IsSet() {
		localVarQueryParams.Add("enableRedirection", parameterToString(localVarOptionals.EnableRedirection.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"audio/_*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["X-Emby-Authorization"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// HeadUniversalAudioStreamOpts Optional parameters for the method 'HeadUniversalAudioStream'
type HeadUniversalAudioStreamOpts struct {
    MediaSourceId optional.String
    DeviceId optional.String
    UserId optional.Interface
    AudioCodec optional.String
    MaxAudioChannels optional.Int32
    TranscodingAudioChannels optional.Int32
    MaxStreamingBitrate optional.Int64
    StartTimeTicks optional.Int64
    TranscodingContainer optional.String
    TranscodingProtocol optional.String
    MaxAudioSampleRate optional.Int32
    MaxAudioBitDepth optional.Int32
    EnableRemoteMedia optional.Bool
    BreakOnNonKeyFrames optional.Bool
    EnableRedirection optional.Bool
}

/*
HeadUniversalAudioStream Gets an audio stream.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param itemId The item id.
 * @param container Optional. The audio container.
 * @param optional nil or *HeadUniversalAudioStreamOpts - Optional Parameters:
 * @param "MediaSourceId" (optional.String) -  The media version id, if playing an alternate version.
 * @param "DeviceId" (optional.String) -  The device id of the client requesting. Used to stop encoding processes when needed.
 * @param "UserId" (optional.Interface of string) -  Optional. The user id.
 * @param "AudioCodec" (optional.String) -  Optional. The audio codec to transcode to.
 * @param "MaxAudioChannels" (optional.Int32) -  Optional. The maximum number of audio channels.
 * @param "TranscodingAudioChannels" (optional.Int32) -  Optional. The number of how many audio channels to transcode to.
 * @param "MaxStreamingBitrate" (optional.Int64) -  Optional. The maximum streaming bitrate.
 * @param "StartTimeTicks" (optional.Int64) -  Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms.
 * @param "TranscodingContainer" (optional.String) -  Optional. The container to transcode to.
 * @param "TranscodingProtocol" (optional.String) -  Optional. The transcoding protocol.
 * @param "MaxAudioSampleRate" (optional.Int32) -  Optional. The maximum audio sample rate.
 * @param "MaxAudioBitDepth" (optional.Int32) -  Optional. The maximum audio bit depth.
 * @param "EnableRemoteMedia" (optional.Bool) -  Optional. Whether to enable remote media.
 * @param "BreakOnNonKeyFrames" (optional.Bool) -  Optional. Whether to break on non key frames.
 * @param "EnableRedirection" (optional.Bool) -  Whether to enable redirection. Defaults to true.
@return *os.File
*/
func (a *UniversalAudioApiService) HeadUniversalAudioStream(ctx _context.Context, itemId string, container string, localVarOptionals *HeadUniversalAudioStreamOpts) (*os.File, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodHead
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  *os.File
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Audio/{itemId}/universal"
	localVarPath = strings.Replace(localVarPath, "{"+"itemId"+"}", _neturl.QueryEscape(parameterToString(itemId, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"container"+"}", _neturl.QueryEscape(parameterToString(container, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.MediaSourceId.IsSet() {
		localVarQueryParams.Add("mediaSourceId", parameterToString(localVarOptionals.MediaSourceId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DeviceId.IsSet() {
		localVarQueryParams.Add("deviceId", parameterToString(localVarOptionals.DeviceId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.UserId.IsSet() {
		localVarQueryParams.Add("userId", parameterToString(localVarOptionals.UserId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AudioCodec.IsSet() {
		localVarQueryParams.Add("audioCodec", parameterToString(localVarOptionals.AudioCodec.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MaxAudioChannels.IsSet() {
		localVarQueryParams.Add("maxAudioChannels", parameterToString(localVarOptionals.MaxAudioChannels.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TranscodingAudioChannels.IsSet() {
		localVarQueryParams.Add("transcodingAudioChannels", parameterToString(localVarOptionals.TranscodingAudioChannels.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MaxStreamingBitrate.IsSet() {
		localVarQueryParams.Add("maxStreamingBitrate", parameterToString(localVarOptionals.MaxStreamingBitrate.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.StartTimeTicks.IsSet() {
		localVarQueryParams.Add("startTimeTicks", parameterToString(localVarOptionals.StartTimeTicks.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TranscodingContainer.IsSet() {
		localVarQueryParams.Add("transcodingContainer", parameterToString(localVarOptionals.TranscodingContainer.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TranscodingProtocol.IsSet() {
		localVarQueryParams.Add("transcodingProtocol", parameterToString(localVarOptionals.TranscodingProtocol.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MaxAudioSampleRate.IsSet() {
		localVarQueryParams.Add("maxAudioSampleRate", parameterToString(localVarOptionals.MaxAudioSampleRate.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MaxAudioBitDepth.IsSet() {
		localVarQueryParams.Add("maxAudioBitDepth", parameterToString(localVarOptionals.MaxAudioBitDepth.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EnableRemoteMedia.IsSet() {
		localVarQueryParams.Add("enableRemoteMedia", parameterToString(localVarOptionals.EnableRemoteMedia.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.BreakOnNonKeyFrames.IsSet() {
		localVarQueryParams.Add("breakOnNonKeyFrames", parameterToString(localVarOptionals.BreakOnNonKeyFrames.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EnableRedirection.IsSet() {
		localVarQueryParams.Add("enableRedirection", parameterToString(localVarOptionals.EnableRedirection.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"audio/_*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["X-Emby-Authorization"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

// HeadUniversalAudioStream2Opts Optional parameters for the method 'HeadUniversalAudioStream2'
type HeadUniversalAudioStream2Opts struct {
    MediaSourceId optional.String
    DeviceId optional.String
    UserId optional.Interface
    AudioCodec optional.String
    MaxAudioChannels optional.Int32
    TranscodingAudioChannels optional.Int32
    MaxStreamingBitrate optional.Int64
    StartTimeTicks optional.Int64
    TranscodingContainer optional.String
    TranscodingProtocol optional.String
    MaxAudioSampleRate optional.Int32
    MaxAudioBitDepth optional.Int32
    EnableRemoteMedia optional.Bool
    BreakOnNonKeyFrames optional.Bool
    EnableRedirection optional.Bool
}

/*
HeadUniversalAudioStream2 Gets an audio stream.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param itemId The item id.
 * @param container Optional. The audio container.
 * @param optional nil or *HeadUniversalAudioStream2Opts - Optional Parameters:
 * @param "MediaSourceId" (optional.String) -  The media version id, if playing an alternate version.
 * @param "DeviceId" (optional.String) -  The device id of the client requesting. Used to stop encoding processes when needed.
 * @param "UserId" (optional.Interface of string) -  Optional. The user id.
 * @param "AudioCodec" (optional.String) -  Optional. The audio codec to transcode to.
 * @param "MaxAudioChannels" (optional.Int32) -  Optional. The maximum number of audio channels.
 * @param "TranscodingAudioChannels" (optional.Int32) -  Optional. The number of how many audio channels to transcode to.
 * @param "MaxStreamingBitrate" (optional.Int64) -  Optional. The maximum streaming bitrate.
 * @param "StartTimeTicks" (optional.Int64) -  Optional. Specify a starting offset, in ticks. 1 tick = 10000 ms.
 * @param "TranscodingContainer" (optional.String) -  Optional. The container to transcode to.
 * @param "TranscodingProtocol" (optional.String) -  Optional. The transcoding protocol.
 * @param "MaxAudioSampleRate" (optional.Int32) -  Optional. The maximum audio sample rate.
 * @param "MaxAudioBitDepth" (optional.Int32) -  Optional. The maximum audio bit depth.
 * @param "EnableRemoteMedia" (optional.Bool) -  Optional. Whether to enable remote media.
 * @param "BreakOnNonKeyFrames" (optional.Bool) -  Optional. Whether to break on non key frames.
 * @param "EnableRedirection" (optional.Bool) -  Whether to enable redirection. Defaults to true.
@return *os.File
*/
func (a *UniversalAudioApiService) HeadUniversalAudioStream2(ctx _context.Context, itemId string, container string, localVarOptionals *HeadUniversalAudioStream2Opts) (*os.File, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodHead
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  *os.File
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/Audio/{itemId}/universal.{container}"
	localVarPath = strings.Replace(localVarPath, "{"+"itemId"+"}", _neturl.QueryEscape(parameterToString(itemId, "")) , -1)

	localVarPath = strings.Replace(localVarPath, "{"+"container"+"}", _neturl.QueryEscape(parameterToString(container, "")) , -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if localVarOptionals != nil && localVarOptionals.MediaSourceId.IsSet() {
		localVarQueryParams.Add("mediaSourceId", parameterToString(localVarOptionals.MediaSourceId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DeviceId.IsSet() {
		localVarQueryParams.Add("deviceId", parameterToString(localVarOptionals.DeviceId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.UserId.IsSet() {
		localVarQueryParams.Add("userId", parameterToString(localVarOptionals.UserId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AudioCodec.IsSet() {
		localVarQueryParams.Add("audioCodec", parameterToString(localVarOptionals.AudioCodec.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MaxAudioChannels.IsSet() {
		localVarQueryParams.Add("maxAudioChannels", parameterToString(localVarOptionals.MaxAudioChannels.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TranscodingAudioChannels.IsSet() {
		localVarQueryParams.Add("transcodingAudioChannels", parameterToString(localVarOptionals.TranscodingAudioChannels.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MaxStreamingBitrate.IsSet() {
		localVarQueryParams.Add("maxStreamingBitrate", parameterToString(localVarOptionals.MaxStreamingBitrate.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.StartTimeTicks.IsSet() {
		localVarQueryParams.Add("startTimeTicks", parameterToString(localVarOptionals.StartTimeTicks.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TranscodingContainer.IsSet() {
		localVarQueryParams.Add("transcodingContainer", parameterToString(localVarOptionals.TranscodingContainer.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TranscodingProtocol.IsSet() {
		localVarQueryParams.Add("transcodingProtocol", parameterToString(localVarOptionals.TranscodingProtocol.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MaxAudioSampleRate.IsSet() {
		localVarQueryParams.Add("maxAudioSampleRate", parameterToString(localVarOptionals.MaxAudioSampleRate.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MaxAudioBitDepth.IsSet() {
		localVarQueryParams.Add("maxAudioBitDepth", parameterToString(localVarOptionals.MaxAudioBitDepth.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EnableRemoteMedia.IsSet() {
		localVarQueryParams.Add("enableRemoteMedia", parameterToString(localVarOptionals.EnableRemoteMedia.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.BreakOnNonKeyFrames.IsSet() {
		localVarQueryParams.Add("breakOnNonKeyFrames", parameterToString(localVarOptionals.BreakOnNonKeyFrames.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EnableRedirection.IsSet() {
		localVarQueryParams.Add("enableRedirection", parameterToString(localVarOptionals.EnableRedirection.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"audio/_*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if ctx != nil {
		// API Key Authentication
		if auth, ok := ctx.Value(ContextAPIKey).(APIKey); ok {
			var key string
			if auth.Prefix != "" {
				key = auth.Prefix + " " + auth.Key
			} else {
				key = auth.Key
			}
			localVarHeaderParams["X-Emby-Authorization"] = key
		}
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(r)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
